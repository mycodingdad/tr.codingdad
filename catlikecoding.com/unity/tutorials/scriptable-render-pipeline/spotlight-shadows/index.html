<!DOCTYPE html><html lang="ko"><head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/">
		<meta property="og:type" content="&#xAE00;">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/tutorial-image.jpg">
		<meta property="og:title" content="&#xC2A4;&#xD3EC;&#xD2B8;&#xB77C;&#xC774;&#xD2B8; &#xADF8;&#xB9BC;&#xC790;">
		<meta property="og:description" content="A Unity Scriptable Render Pipeline tutorial about spotlight shadows for sigle-pass forward rendering.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>&#xC2A4;&#xD3EC;&#xD2B8;&#xB77C;&#xC774;&#xD2B8; &#xADF8;&#xB9BC;&#xC790;</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="publisher" href="https://plus.google.com/+CatlikeCoding">
		<link rel="manifest" href="https://catlikecoding.com/site.webmanifest">
		<link rel="mask-icon" href="https://catlikecoding.com/safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/#article",
				"headline": "Spotlight Shadows",
				"alternativeHeadline": "Shadow Maps",
				"datePublished": "2018-12-30",
				"dateModified": "2019-01-09",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Scriptable Render Pipeline tutorial about spotlight shadows for single-pass forward rendering.",
				"image": "https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/tutorial-image.jpg",
				"dependencies": "Unity 2018.3.0f2",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/", "name": "Scriptable Render Pipeline" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				InstancedColor: 1,
				MyPipeline: 1,
				MyPipelineAsset: 1,
				ShadowMapSize: 1
			};
		</script>
	<style class="codingdad_header_css">  .codingdad_header
  {
    padding:10px 10px 10px 100px; 
    background-color:#36c46f; 
    color:#f4f0f4; 
    border-radius:15px; 
    margin:10px;
  }
  .codingdad_header a
  {
    text-decoration:underline;
    color:#f4f0f4;
  }
  .codingdad_header_title
  {
    font-size:25px; 
    font-weight:bold;
  }
  .codingdad_header_desc
  {
    font-size:13px; 
    line-height:1.2em; 
    margin-top:10px;
  }
  .codingdad_header_desc ul
  {
    margin-bottom:0px;
    margin-left:-40px;
  }</style></head>
	<body><div class="codingdad_header_html"><div class="codingdad_header"> 
  <div class="codingdad_header_title">
    <a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/">Catlike Coding</a>&#xC758; &#xBA4B;&#xC9C4; &#xAE00;&#xC744; 
    <a href="undefined/2018/12/25/catlike-rendering-part-1">Coding Dad</a>&#xC774; &#xBC88;&#xC5ED;&#xD588;&#xC2B5;&#xB2C8;&#xB2E4;.
  </div>
  <div class="codingdad_header_desc">
    <ul>
      <li>&#xB9C1;&#xD06C;&#xB97C; &#xD1B5;&#xD574; <a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/">catlikecoding.com</a>&#xC758; &#xC6D0;&#xBCF8;&#xAE00;&#xC744; &#xBCF4;&#xC2DC;&#xAC70;&#xB098;, <a href="undefined/2018/12/25/catlike-rendering-part-1">codingdad.me</a>&#xC5D0;&#xC11C; &#xD53C;&#xB4DC;&#xBC31;&#xC744; &#xB0A8;&#xAE30;&#xC2E4; &#xC218; &#xC788;&#xC2B5;&#xB2C8;&#xB2E4;. </li>
      <li>&#xD6C4;&#xC6D0; &#xBC0F; &#xAE30;&#xBD80; &#xB9C1;&#xD06C;&#xB294; Catlike Coding&#xC5D0; &#xC5F0;&#xACB0;&#xB429;&#xB2C8;&#xB2E4;. &#xD6CC;&#xB96D;&#xD55C; &#xAE00;&#xC744; &#xCC3D;&#xC791;&#xD55C; &#xBD84;&#xC5D0;&#xAC8C; &#xAC10;&#xC0AC;&#xC758; &#xB9C8;&#xC74C;&#xC744; &#xC804;&#xD560; &#xC218; &#xC788;&#xC2B5;&#xB2C8;&#xB2E4;.</li>
    </ul>
  </div>
</div></div>
		<header>
			<a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/catlikecoding.com/"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"><sup class="codingdad_ext_link">&#x1F517;</sup></a>
			<nav>
				<ol>
					<li><a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/catlikecoding.com/">Catlike Coding<sup class="codingdad_ext_link">&#x1F517;</sup></a></li>
					<li><a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/catlikecoding.com/unity/">&#xC720;&#xB2C8;&#xD2F0;<sup class="codingdad_ext_link">&#x1F517;</sup></a></li>
					<li><a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/catlikecoding.com/unity/tutorials/">&#xD29C;&#xD1A0;&#xB9AC;&#xC5BC;<sup class="codingdad_ext_link">&#x1F517;</sup></a></li>
					<li><a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/catlikecoding.com/unity/tutorials/scriptable-render-pipeline/">&#xC2A4;&#xD06C;&#xB9BD;&#xD130;&#xBE14; &#xB80C;&#xB354; &#xD30C;&#xC774;&#xD504;&#xB77C;&#xC778;<sup class="codingdad_ext_link">&#x1F517;</sup></a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>&#xC2A4;&#xD3EC;&#xD2B8;&#xB77C;&#xC774;&#xD2B8; &#xADF8;&#xB9BC;&#xC790;</h1>
					<p>Shadow Maps</p>
					<ul>
						<li>Both render to and read from a texture.</li>
						<li>Render from the point of view of a light.</li>
						<li>Add a shader pass for shadow casters.</li>
						<li>Sample a shadow map.</li>
						<li>Support a mix of hard and soft shadows.</li>
						<li>Combine up to sixteen shadow maps in a single atlas.</li>
					</ul>
				</header>
				
				<p>This is the fourth installment of a tutorial series covering Unity&apos;s <a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/catlikecoding.com/unity/tutorials/scriptable-render-pipeline/">scriptable render pipeline<sup class="codingdad_ext_link">&#x1F517;</sup></a>. In it, we&apos;ll add support for up to sixteen spotlights with shadows.</p>
				
				<p>&#xC774; &#xD29C;&#xD1A0;&#xB9AC;&#xC5BC;&#xC740; &#xC720;&#xB2C8;&#xD2F0; 2018.3.0f2&#xB97C; &#xC0AC;&#xC6A9;&#xD558;&#xC5EC; &#xC791;&#xC131;&#xB418;&#xC5C8;&#xC2B5;&#xB2C8;&#xB2E4;.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Three spotlights with shadows.</figcaption>
				</figure>
				
				<section>
					<h2>A Spotlight With Shadows</h2>
					
					<p>Shadows are very important, both to increase realism and to make the spatial relationship between objects more obvious. Without shadows, it can be hard to tell whether something floats about a surface or sits on top of it.</p>
					
					<p>The <a href="https://catlikecoding.com/unity/tutorials/rendering/part-7/">Rendering 7, Shadows<sup class="codingdad_ext_link">&#x1F517;</sup></a> tutorial explains how shadows work in Unity&apos;s default render pipeline, but that exact same approach doesn&apos;t work for our single-pass forward renderer. It is still useful to skim to get the gist of shadow maps though. In this tutorial we&apos;ll limit ourselves to shadows for spotlights, are they&apos;re the least complicated.</p>
					
					<p>We start with supporting exactly one shadowed light, so make a scene that contains a few objects and a single spotlight. A plane object is useful to receive shadows. All objects should use our <em>Lit Opaque</em> material.</p>
					
					<figure>
						<img src="a-spotlight-with-shadows/no-shadows.jpg" width="370" height="210">
						<figcaption>A single spotlight, no shadows yet.</figcaption>
					</figure>
					
					<section>
						<h3>Shadow Map</h3>
						
						<p>There are a few different ways to deal with shadows, but we&apos;ll stick to the default approach of using a shadow map. This means that we&apos;ll render the scene from the light&apos;s point of view. We&apos;re only interested in the depth information of this render, because that tells us how far the light reaches before it hits a surface. Anything that&apos;s further away lies in shadows.</p>
						
						<p>To use a shadow map we have to create it before rendering with the normal camera. To be able to sample the shadow map later, we have to render into a separate render texture instead of the usual frame buffer. Add a <code>RenderTexture</code> field to <code>MyPipeline</code> to keep a reference to the shadow map texture.</p>
						
						<pre>	<ins>RenderTexture shadowMap;</ins></pre>
						
						<p>Create a separate method to render the shadows, with the context as a parameter. The first thing it has to do is get hold of a render texture. We&apos;ll do that by invoking the static <code>RenderTexture.GetTemporary</code> method. That either creates a new render texture or reuses an old one that hasn&apos;t been cleaned up yet. As we&apos;ll most likely need the shadow map every frame, it will get reused all the time.</p>
						
						<p>Supply <code>RenderTexture.GetTemporary</code> with our map&apos;s width and height, the amount of bits used for the depth channel, and finally the texture format. We&apos;ll start with a fixed size of 512&#xD7;512. We&apos;ll use 16 bits for the depth channel, so it is high-precision. As we&apos;re creating a shadow map, use the <code>RenderTextureFormat.Shadowmap</code> format.</p>
						
						<pre>	<ins>void RenderShadows (ScriptableRenderContext context) {</ins>
		<ins>shadowMap = RenderTexture.GetTemporary(</ins>
			<ins>512, 512, 16, RenderTextureFormat.Shadowmap</ins>
		<ins>);</ins>
	<ins>}</ins></pre>
						
						<p>Make sure that the texture&apos;s filter mode is set the bilinear and its wrap mode is set to clamp.</p>
						
						<pre>		shadowMap = RenderTexture.GetTemporary(
			512, 512, 16, RenderTextureFormat.Shadowmap
		);
		<ins>shadowMap.filterMode = FilterMode.Bilinear;</ins>
		<ins>shadowMap.wrapMode = TextureWrapMode.Clamp;</ins></pre>
						
						<p>The shadow map is to be rendered before the regular scene, so invoke <code>RenderShadows</code> in <code>Render</code> before we setup the regular camera, but after culling.</p>
						
						<pre>	void Render (ScriptableRenderContext context, Camera camera) {
		&#x2026;
		CullResults.Cull(ref cullingParameters, context, ref cull);

		<ins>RenderShadows(context);</ins>

		context.SetupCameraProperties(camera);

		&#x2026;
	}</pre>
						
						<p>Also, make sure to release the render texture when we&apos;re done, after we&apos;ve submitted the context. If we have a shadow map at that point, pass it to the <code>RenderTexture.ReleaseTemporary</code> method and clear our field.</p>
						
						<pre>	void Render (ScriptableRenderContext context, Camera camera) {
		&#x2026;
		
		context.Submit();

		<ins>if (shadowMap) {</ins>
			<ins>RenderTexture.ReleaseTemporary(shadowMap);</ins>
			<ins>shadowMap = null;</ins>
		<ins>}</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Shadow Command Buffer</h3>
						
						<p>We&apos;ll use a separate command buffer for all the shadow work, so we can see the shadow and regular rendering in separate sections in the frame debugger.</p>
						
						<pre>	CommandBuffer cameraBuffer = new CommandBuffer {
		name = &quot;Render Camera&quot;
	};

	<ins>CommandBuffer shadowBuffer = new CommandBuffer {</ins>
		<ins>name = &quot;Render Shadows&quot;</ins>
	<ins>};</ins></pre>
						
						<p>The shadow rendering will happen in between <code>BeginSample</code> and <code>EndSample</code> commands, just like we do for regular rendering.</p>
						
						<pre>	void RenderShadows (ScriptableRenderContext context) {
		shadowMap = RenderTexture.GetTemporary(
			512, 512, 16, RenderTextureFormat.Shadowmap
		);
		shadowMap.filterMode = FilterMode.Bilinear;
		shadowMap.wrapMode = TextureWrapMode.Clamp;

		<ins>shadowBuffer.BeginSample(&quot;Render Shadows&quot;);</ins>
		<ins>context.ExecuteCommandBuffer(shadowBuffer);</ins>
		<ins>shadowBuffer.Clear();</ins>

		<ins>shadowBuffer.EndSample(&quot;Render Shadows&quot;);</ins>
		<ins>context.ExecuteCommandBuffer(shadowBuffer);</ins>
		<ins>shadowBuffer.Clear();</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Setting the Render Target</h3>
						
						<p>Before we can render shadows, we first have tell the GPU to render to our shadow map. A convenient way to do this is by invoking <code>CoreUtils.SetRenderTarget</code> with our command buffer and shadow map as arguments. As we start with clearing the map, invoke it before <code>BeginSample</code> so the frame debugger doesn&apos;t show and extra nested <em>Render Shadows</em> level.</p>
						
						<pre>		<ins>CoreUtils.SetRenderTarget(shadowBuffer, shadowMap);</ins>
		shadowBuffer.BeginSample(&quot;Render Shadows&quot;);
		context.ExecuteCommandBuffer(shadowBuffer);
		shadowBuffer.Clear();</pre>
						
						<p>We only care about the depth channel, so only that channel needs to be cleared. Indicate this by adding <code>ClearFlag.Depth</code> as a third argument to <code>SetRenderTarget</code>.</p> 
						
						<pre>		CoreUtils.SetRenderTarget(
			shadowBuffer, shadowMap<ins>,</ins>
			<ins>ClearFlag.Depth</ins>
		);</pre>
						
						<p>While not necessary, we can also be more precise about the load and storage requirements of our texture. We don&apos;t care where it comes from, as we clear it anyway, which we can indicate with <code>RenderBufferLoadAction.DontCare</code>. That makes it possible for tile-based GPUs to be a bit more efficient. And we need to sample from the texture later, so it needs to be kept in memory, which we indicate with <code>RenderBufferStoreAction.Store</code>. Add these as the third and fourth arguments.</p>
						
						<pre>		CoreUtils.SetRenderTarget(
			shadowBuffer, shadowMap,
			<ins>RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store,</ins>
			ClearFlag.Depth
		);</pre>
						
						<p>The clear action for our shadow map now shows up in the frame debugger, before the regular camera render.</p>
						
						<figure>
							<img src="a-spotlight-with-shadows/frame-debugger-render-shadows.png" width="298" height="52">
							<figcaption>Clearing the shadow map.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Configuring the View and Projection Matrices</h3>
						
						<p>The idea is that we render from the point of view of the light source, which means that we&apos;re using the spotlight as if it were a camera. Thus, we have to provide appropriate view and projection matrices. We can retrieve these matrices by invoking <code>ComputeSpotShadowMatricesAndCullingPrimitives</code> on our cull results with the light index as an argument. As we only have a single spotlight in the scene, we simply supply zero. The view and projection matrices are made available via two output parameters. Besides that, there is a third <code>ShadowSplitData</code> output parameter. We don&apos;t need it, must supply the output argument.</p>
						
						<pre>		shadowBuffer.BeginSample(&quot;Render Shadows&quot;);
		context.ExecuteCommandBuffer(shadowBuffer);</pre></section></section></article></main>e, depending on how many tiles are needed. That way we can ensure that always at least half of the texture gets used.<p></p>
					
					<section>
						<h3>Counting Shadow Tiles</h3>
						
						<p>First, we need to determine how many tiles are needed. We can do that by counting how many shadowed spotlights we encounter in <code>ConfigureLights</code>. Keep track of the total in a field so we can use it later.</p>
						
						<pre>	<ins>int shadowTileCount;</ins>

&#x2026;

	void ConfigureLights () {
		<ins>shadowTileCount = 0;</ins>
		for (int i = 0; i &lt; cull.visibleLights.Count; i++) {
			&#x2026;
			else {
				&#x2026;

				if (light.lightType == LightType.Spot) {
					&#x2026;
					if (
						shadowLight.shadows != LightShadows.None &amp;&amp;
						cull.GetShadowCasterBounds(i, out shadowBounds)
					) {
						<ins>shadowTileCount += 1;</ins>
						shadow.x = shadowLight.shadowStrength;
						shadow.y =
							shadowLight.shadows == LightShadows.Soft ? 1f : 0f;
					}
				}
			}
			&#x2026;
		}
		&#x2026;
	}</pre>
					</section>
					
					<section>
						<h3>Splitting the Shadow Map</h3>
						
						<p>Next, we&apos;ll determine how we have to split the shadow map at the beginning of <code>RenderShadows</code>. Keep track of this with an integer variable. If we have at most a single tile, then we don&apos;t need to split at all, so the split amount is 1. Otherwise, if we have at most four tiles then the split becomes 2. The next step is up to nine tiles, with a split of 3. Only when ten or more tiles are in use do we need to use a split of 4.</p>
						
						<pre>	void RenderShadows (ScriptableRenderContext context) {
		<ins>int split;</ins>
		<ins>if (shadowTileCount &lt;= 1) {</ins>
			<ins>split = 1;</ins>
		<ins>}</ins>
		<ins>else if (shadowTileCount &lt;= 4) {</ins>
			<ins>split = 2;</ins>
		<ins>}</ins>
		<ins>else if (shadowTileCount &lt;= 9) {</ins>
			<ins>split = 3;</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>split = 4;</ins>
		<ins>}</ins>
		&#x2026;
	}</pre>
						
						<p>The tile size is now found by dividing the shadow map size by the split amount. Note that this is an integer division. In the case of a division by three, this means that we end up discarding fractional texels, which is intended. The tile scale then becomes one divided by the split amount, in this case using a float division. Then use the split amount when determining the tile offset and the tile scale when adjusting the world-to-shadow matrix.</p>
						
						<pre>		float tileSize = shadowMapSize / <ins>split</ins>;
		<ins>float tileScale = 1f / split;</ins>
		&#x2026;

		for (int i = 0; i &lt; cull.visibleLights.Count; i++) {
			&#x2026;

			float tileOffsetX = i % <ins>split</ins>;
			float tileOffsetY = i / <ins>split</ins>;
			&#x2026;
			
			tileMatrix.m00 = tileMatrix.m11 = <ins>tileScale</ins>;
			tileMatrix.m03 = tileOffsetX * <ins>tileScale</ins>;
			tileMatrix.m13 = tileOffsetY * <ins>tileScale</ins>;
			&#x2026;
		}</pre>
						
						<p>To pack all shadow maps in the available space, we must only increment the tile index when we used up a tile. So use a separate variable to keep track of it instead of relying on the light index. Increment it at the end of each iteration that we didn&apos;t skip.</p>
						
						<pre>		<ins>int tileIndex = 0;</ins>
		for (int i = 0; i &lt; cull.visibleLights.Count; i++) {
			&#x2026;

			float tileOffsetX = <ins>tileIndex</ins> % split;
			float tileOffsetY = <ins>tileIndex</ins> / split;
			&#x2026;
			<ins>tileIndex += 1;</ins>
		}</pre>
						
						<figure>
							<img src="dynamic-tiling/six-out-of-nine.png" width="254" height="254">
							<figcaption>Six out of nine tiles in use.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>One Tile is No Tile</h3>
						
						<p>Finally, if we end up with only a single tile it is not needed to set the viewport and change the scissor state at all. So only do that when there are multiple tiles.</p>
						
						<pre>		for (int i = 0; i &lt; cull.visibleLights.Count; i++) {
			&#x2026;

			<ins>if (split &gt; 1) {</ins>
				shadowBuffer.SetViewport(tileViewport);
				shadowBuffer.EnableScissorRect(new Rect(
					tileViewport.x + 4f, tileViewport.y + 4f,
					tileSize - 8f, tileSize - 8f
				));
			<ins>}</ins>
			shadowBuffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);
			&#x2026;

			<ins>if (split &gt; 1) {</ins>
				var tileMatrix = Matrix4x4.identity;
				tileMatrix.m00 = tileMatrix.m11 = tileScale;
				tileMatrix.m03 = tileOffsetX * tileScale;
				tileMatrix.m13 = tileOffsetY * tileScale;
				worldToShadowMatrices[i] = tileMatrix * worldToShadowMatrices[i];
			<ins>}</ins>
			tileIndex += 1;
		}

		<ins>if (split &gt; 1) {</ins>
			shadowBuffer.DisableScissorRect();
		<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Shader Keywords</h3>
						
						<p>We can now end up sampling shadows up to four times per fragment, which can be a combination of hard and soft shadows. In the worst case we have four soft shadows, requiring 36 shadow samples. But we have branches in our shader to only sample shadows when needed, which works well because fragments from the same object end up branching the same way. However, we can switch to less complex shader alternatives by distinguishing between different combinations of shadows.</p>
						
						<p>There are four possible configurations. The first case is that there are no shadows at all. The second case is that there are only hard shadows. Third, there are only soft shadows. And the most complex case is a combination of hard and soft shadows. We can make shader variants for all cases by using the independent <em>_SHADOWS_HARD</em> and <em>_SHADOWS_SOFT</em> keywords.</p>
						
						<p>In <code>RenderShadows</code>, use two boolean variables to separately keep track of whether we have hard or soft shadows, based on whether the Y component of the shadows data is set to 0 or 1. Use these booleans after the loop to toggle the shader keywords.</p>
						
						<pre>	<ins>const string shadowsHardKeyword = &quot;_SHADOWS_HARD&quot;;</ins>
	&#x2026;
	
	void RenderShadows (ScriptableRenderContext context) {
		&#x2026;
		
		int tileIndex = 0;
		<ins>bool hardShadows = false;</ins>
		<ins>bool softShadows = false;</ins>
		for (int i = 0; i &lt; cull.visibleLights.Count; i++) {
			&#x2026;
			
			<ins>if (shadowData[i].y &lt;= 0f) {</ins>
				<ins>hardShadows = true;</ins>
			<ins>}</ins>
			<ins>else {</ins>
				<ins>softShadows = true;</ins>
			<ins>}</ins>
		}

		&#x2026;
		<ins>CoreUtils.SetKeyword(shadowBuffer, shadowsHardKeyword, hardShadows);</ins>
		CoreUtils.SetKeyword(shadowBuffer, shadowsSoftKeyword, <ins>softShadows</ins>);
		&#x2026;
	}</pre>
						
						<p>Add another multi-compile directive to the shader, now for <em>_SHADOWS_HARD</em>.</p>
						
						<pre class="shader">			<ins>#pragma multi_compile _ _SHADOWS_HARD</ins>
			#pragma multi_compile _ _SHADOWS_SOFT</pre>
						
						<p>In the <code class="shader">ShadowAttenuation</code> function, begin by returning 1 if neither keyword is defined. That cuts off the rest of the function, completely eliminating shadows.</p>
						
						<pre class="shader">float ShadowAttenuation (int index, float3 worldPos) {
	<ins>#if !defined(_SHADOWS_HARD) &amp;&amp; !defined(_SHADOWS_SOFT)</ins>
		<ins>return 1.0;</ins>
	<ins>#endif</ins>
	if (_ShadowData[index].x &lt;= 0) {
		return 1.0;
	}
	&#x2026;
}</pre>
						
						<p>To make the code a more legible, move the sampling code for hard and soft shadows to their own functions.</p>
						
						<pre class="shader"><ins>float HardShadowAttenuation (float4 shadowPos) {</ins>
	<ins>return</ins> SAMPLE_TEXTURE2D_SHADOW(_ShadowMap, sampler_ShadowMap, shadowPos.xyz);
<ins>}</ins>

<ins>float SoftShadowAttenuation (float4 shadowPos) {</ins>
	real tentWeights[9];
	real2 tentUVs[9];
	SampleShadow_ComputeSamples_Tent_5x5(
		_ShadowMapSize, shadowPos.xy, tentWeights, tentUVs
	);
	<ins>float</ins> attenuation = 0;
	for (int i = 0; i &lt; 9; i++) {
		attenuation += tentWeights[i] * SAMPLE_TEXTURE2D_SHADOW(
			_ShadowMap, sampler_ShadowMap, float3(tentUVs[i].xy, shadowPos.z)
		);
	}
	<ins>return attenuation;</ins>
<ins>}</ins>

float ShadowAttenuation (int index, float3 worldPos) {
	&#x2026;
	float attenuation;
	
	if (_ShadowData[index].y == 0) {
		<ins>attenuation = HardShadowAttenuation(shadowPos);</ins>
	}
	else {
		<ins>attenuation = SoftShadowAttenuation(shadowPos);</ins>
	}
	
	return lerp(1, attenuation, _ShadowData[index].x);
}</pre>
						
						<p>Now we can use the keywords to create code for the other three cases. The original branch is only needed if both keywords are defined.</p>
						
						<pre class="shader">	<ins>#if defined(_SHADOWS_HARD)</ins>
		<ins>#if defined(_SHADOWS_SOFT)</ins>
			if (_ShadowData[index].y == 0) {
				attenuation = HardShadowAttenuation(shadowPos);
			}
			else {
				attenuation = SoftShadowAttenuation(shadowPos);
			}
		<ins>#else</ins>
			<ins>attenuation = HardShadowAttenuation(shadowPos);</ins>
		<ins>#endif</ins>
	<ins>#else</ins>
		<ins>attenuation = SoftShadowAttenuation(shadowPos);</ins>
	<ins>#endif</ins></pre>
						
						<p>Finally, we can completely skip invoking <code>RenderShadows</code> in <code>MyPipeline.Render</code> if we need no shadow tiles at all. We won&apos;t even clear the shadow map. If we skip it, we do have to make sure that both shadow keywords are disabled. They can also be disabled when there are no visible lights.</p>
						
					<pre>		if (cull.visibleLights.Count &gt; 0) {
			ConfigureLights();
			<ins>if (shadowTileCount &gt; 0) {</ins>
				RenderShadows(context);
			<ins>}</ins>
			<ins>else {</ins>
				<ins>cameraBuffer.DisableShaderKeyword(shadowsHardKeyword);</ins>
				<ins>cameraBuffer.DisableShaderKeyword(shadowsSoftKeyword);</ins>
			<ins>}</ins>
		}
		else {
			cameraBuffer.SetGlobalVector(
				lightIndicesOffsetAndCountID, Vector4.zero
			);
			<ins>cameraBuffer.DisableShaderKeyword(shadowsHardKeyword);</ins>
			<ins>cameraBuffer.DisableShaderKeyword(shadowsSoftKeyword);</ins>
		}</pre>
					
					<p>We now support spotlight shadows. The next tutorial will move on to directional shadows. Want to know when it is released? Keep tabs on my <a href="https://www.patreon.com/catlikecoding/">Patreon</a> page!</p>
					</section>
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/scriptable-render-pipeline-04-spotlight-shadows/" class="repository">repository</a>
					<a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/spotlight-shadows/Spotlight-Shadows.pdf/" download="" rel="nofollow">PDF<sup class="codingdad_ext_link">&#x1F517;</sup></a>
				
				
			
		

		<footer>
			<p><a href="/catlikecoding.com/unity/tutorials/">&#xD29C;&#xD1A0;&#xB9AC;&#xC5BC;</a>&#xC744; &#xC990;&#xAE30;&#xACE0; &#xACC4;&#xC138;&#xC694;? &#xB3C4;&#xC6C0;&#xC774; &#xB418;&#xB098;&#xC694;? &#xB354; &#xC6D0;&#xD558;&#xC138;&#xC694;?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding/">Patreon&#xC5D0;&#xC11C; &#xC800;&#xB97C; &#xC9C0;&#xC6D0;&#xD574;&#xC8FC;&#xC138;&#xC694;!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding/"><img src="../../become-a-patron.png" alt="&#xC800;&#xC758; &#xD6C4;&#xC6D0;&#xC790;&#xAC00; &#xB418;&#xC5B4; &#xC8FC;&#xC138;&#xC694;!" width="217" height="51"></a></p>
			<p><b><a href="/catlikecoding.com/unity/tutorials/donating.html">&#xD639;&#xC740; &#xC9C1;&#xC811; &#xAE30;&#xBD80;&#xD574; &#xC8FC;&#xC138;&#xC694;</a>!</b></p>
			<p><a href="/catlikecoding.com/jasper-flick/" rel="author">Jasper Flick</a>&#xC5D0; &#xC758;&#xD574; &#xC791;&#xC131;&#xB418;&#xC5C8;&#xC2B5;&#xB2C8;&#xB2E4;</p>
		</footer>
		
		<script src="../../jquery.js"></script>
		<script src="../../tutorials.js"></script>
	
</body></html>