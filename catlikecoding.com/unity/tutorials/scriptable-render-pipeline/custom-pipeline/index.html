<!DOCTYPE html>
<html lang="ko">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/">
		<meta property="og:type" content="글">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/tutorial-image.jpg">
		<meta property="og:title" content="커스텀 파이프라인">
		<meta property="og:description" content="커스텀 파이프라인 생성에 대한 유니티 스크립터블 렌더 파이프라인 튜토리얼">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>커스텀 파이프라인</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="publisher" href="https://plus.google.com/+CatlikeCoding">
		<link rel="manifest" href="https://catlikecoding.com/site.webmanifest">
		<link rel="mask-icon" href="https://catlikecoding.com/safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/#article",
				"headline": "Custom Pipeline",
				"alternativeHeadline": "Taking Control of Rendering",
				"datePublished": "2018-09-30",
				"dateModified": "2019-01-09",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Scriptable Render Pipeline tutorial about creating a custom pipeline.",
				"image": "https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/tutorial-image.jpg",
				"dependencies": "Unity 2018.3.0f2",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/", "name": "Scriptable Render Pipeline" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				MyPipeline: 1,
				MyPipelineAsset: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="https://catlikecoding.com"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="https://catlikecoding.com">Catlike Coding</a></li>
					<li><a href="https://catlikecoding.com/unity/">유니티</a></li>
					<li><a href="https://catlikecoding.com/unity/tutorials/">튜토리얼</a></li>
					<li><a href="../index.html">스크립터블 렌더 파이프라인</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>커스텀 파이프라인</h1>
					<p>렌더링의 제어</p>
					<ul>
						<li>파이프라인 애셋과 인스턴스를 생성하기.</li>
						<li>컬링, 필터링, 정렬, 렌더링.</li>
						<li>메모리를 깨끗하게 유지하기</li>
						<li>좋은 편집 경험을 제공하기</li>
					</ul>
				</header>
				
				<p>유니티의 <a href="../index.html">스크립터블 렌더 파이프라인</a>을 다루는 튜토리얼 연재의 첫 번째 편입니다. 이 튜토리얼은 여러분이 <a href="https://catlikecoding.com/unity/tutorials/basics/">기본</a> 연재와 <a href="https://catlikecoding.com/unity/tutorials/procedural-grid/">절차적 그리드</a> 튜토리얼을 읽었다고 가정합니다. <a href="https://catlikecoding.com/unity/tutorials/rendering/">렌더링</a>의 처음 몇 부분도 유용합니다.
				
				<p>이 튜토리얼은 유니티 2018.3.0f2를 사용하여 작성되었습니다.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>새로운 렌더 파이프라인의 탄생</figcaption>
				</figure>
				
				<section>
					<h2>파이프라인 생성하기</h2>
					
					<p>무엇인가를 그리기 위해서 유니티는 어떤 형체들이 언제, 어디서, 어떤 설정으로 그려질지 결정해야 합니다. 이는 얼마나 많은 효과가 포함되는지에 따라서 매우 복잡해질 수 있습니다. 라이트, 그림자, 투명도, 이미지 이펙트, 볼륨 효과 등을 모두 올바른 순서로 처리해야 최종 이미지에 도달할 수 있습니다. 이 과정은 렌더 파이프라인이라고 알려져 있습니다.</p>
					
					<p>유니티 2017은 두 개의 미리 정의된 렌더 파이프라인을 지원하는데 하나는 포워드 렌더링이고 다른 하나는 디퍼드(지연된) 렌더링입니다. 유니티 5에서 소개되었던 오래된 디퍼드 렌더링도 아직 지원합니다. 이런 파이프라인들은 고정되어 있습니다. 파이프라인의 특정 부분을 활성화, 비활성화, 오버라이드 할 수 있지만, 유니티의 설계에서 크게 벗어날 수는 없습니다. </p>
					
					<p>유니티 2018에서는 스크립터블 렌더 파이프라인을 지원하기 시작하여 밑바닥부터 새로 파이프라인을 설계할 수 있게 하였지만 컬링을 비롯한 여러 개별적인 단계에서는 여전히 유니티에 의존해야 합니다.  유니티 2018에서는 이 방식으로 만들어진 새 파이프라인이 두 가지 소개되었습니다. 경량(lightweight) 파이프라인과 고화질(high-definition) 파이프라인입니다.  두 파이프라인 모두 아직 프리뷰 단계이고 스크립터블 렌더 파이프라인 API도 아직 실험적인 기술로 표시되어 있습니다.  그러나 이 시점에서도 자체적인 파이프라인을 만들기에는 충분히 안정적입니다. </p>
					
					<p>이 튜토리얼에서 우리는 라이팅 되지 않은(unlit) 형체들을 그리는 최소한의 렌더 파이프라인을 구성하겠습니다. 일단 파이프라인이 동작하면, 라이팅, 그림자 및 고급 기능들을 넣으면서 이어지는 튜토리얼에서 파이프라인을 확장할 수 있습니다. </p>
					
					<section>
						<h3>프로젝트 설정</h3>
						
						<p>유니티 2018을 열고 새 프로젝트를 만드세요. 저는 유니티 2018.2.9f1을 사용중이지만, 2018.2 버전 이상이라면 잘 동작합니다. 애널리틱스를 비활성화한 표준 3D 프로젝트를 만드세요. 우리는 자체적인인 파이프라인을 만들 예정이니 파이프라인 옵션은 선택하지 마세요.</p>
						
						<p>일단 프로젝트가 열리면, <em>Window / Package Manager</em>를 통해 패키지 매니저로 가서 기본으로 포함된 모든 패키지들을 제거하세요. 우리에게는 필요하지 않습니다. <em>Package manager UI</em>만 남겨 두세요. 제거할 수 없습니다.</p>
						
						<figure>
							<img src="creating-a-pipeline/project-start.png" width="200" height="88">
							<figcaption>프로젝트 시작하기.</figcaption>
						</figure>
						
						<p>선형 색 공간에서 작업할 예정인데, 유니티 2018은 아직 감마 공간을 기본으로 사용합니다. 그러니 <em>Edit / Project Settings / Player</em>를 통해 플레이어 설정으로 가서 <em>Other Settings</em>의 <em>Color Space</em>를 <em>Linear</em>로 바꾸세요.</p>
						
						<figure>
							<img src="creating-a-pipeline/linear-color-space.png" width="315" height="68">
							<figcaption>선형 색 공간</figcaption>
						</figure>
						
						<p>우리의 파이프라인을 테스트하기 위해서 몇 개의 간단한 재질이 필요하게 될 겁니다. 저는 네 개의 재질을 만들었습니다. 첫 번째, 빨간색의 기본 스탠다드 불투명 재질. 두 번째, 같은 재질이지만 <em>Rendering Mode</em>가 <em>Transparent</em>로 세팅되고 알파를 줄여놓은 파란색 재질. 세 번째, <em>Unlit/Color</em> 쉐이더를 사용하고 색을 노란색으로 지정한 재질. 그리고 마지막으로 아무 변경 없이<em>Unlit/Transparent</em> 쉐이더를 써서, 순수한 흰색으로 보이는 재질. </p>
						
						<figure>
							<img src="creating-a-pipeline/materials.png" width="200" height="100">
							<figcaption>테스트 재질들</figcaption>
						</figure>
						
						<p>네 개의 재질들 모두를 사용하여 몇 개의 오브젝트로 씬을 채우세요.</p>
						
						<figure>
							<img src="creating-a-pipeline/scene.jpg" width="360" height="140">
							<figcaption>네 개의 재질들을 표시하는 씬</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>파이프라인 애셋</h3>
						
						<p>현재는 유니티가 기본 포워드 렌더링 파이프라인을 사용합니다. 커스텀 파이프라인을 사용하기 위해서는 그래픽스 설정에서 선택해야 합니다. <em>Edit / Project Settings / Graphics</em>를 통해서 찾을 수 있습니다.</p>
						
						<figure>
							<img src="creating-a-pipeline/default-pipeline.png" width="320" height="98">
							<figcaption>기본 파이프라인 사용 중</figcaption>
						</figure>
						
						<p>자체적인 파이프라인을 설정하기 위해서 <em>Scriptable Render Pipeline Settings</em>필드에 파이프라인 애셋을 지정해야 합니다. 그런 애셋들은  <code>ScriptableObject</code> 타입의 <code>RenderPipelineAsset</code>을 확장해야 합니다.</p>
						
						<p>우리의 커스텀 파이프라인 애셋을 위한 새 스크립트를 생성하세요. 파이프라인의 이름을 단순하게 <em>My Pipeline</em>이라고 하겠습니다. 따라서 애셋 타입은 <code>MyPipelineAsset</code>이 되고,  <code>UnityEngine.Experimental.Rendering</code> 네임스페이스에 정의된 <code>RenderPipelineAsset</code>을 확장해야 합니다..</p>
						
						<pre><ins>using UnityEngine;</ins>
<ins>using UnityEngine.Experimental.Rendering;</ins>

<ins>public class MyPipelineAsset : RenderPipelineAsset {}</ins></pre>
						
						<aside>
							<h3>항상 Experimental 네임스페이스에 포함될까요?</h3>
							<div>
								<p>어느 시점에는 <code>UnityEngine.Rendering</code> 혹은 다른 네임스페이스로 옮겨질 겁니다. 그 때 API 역시 변경되지 않았다면, 단지 <code>using</code>문만 업데이트 하면 됩니다.</p>
							</div>
						</aside>
						
						<p>파이프라인 애셋의 주 목적은 유니티에게 렌더링을 담당하는 파이프라인 오브젝트의 인스턴스를 유지할 방법을 제공하는 것입니다.  애셋 자체는 단지 파이프라인 설정을 저장하는 장소이자 핸들입니다. 아직 아무런 설정도 없기 때문에, 유니티에게 파이프라인 오브젝트의 인스턴스를 얻을 방법을 제공해야 합니다. <code>InternalCreatePipeline</code> 메소드를 오버라이드 하면 됩니다. 그러나 아직 파이프라인 오브젝트의 타입을 정의하지 않았으므로, 현재로서는 그냥 <code>null</code>을 리턴하겠습니다.</p>
						
						<p><code>InternalCreatePipeline</code>의 반환 타입은 <code>IRenderPipeline</code>입니다. 타입 이름의 <em>I</em> 접두사는 인터페이스 타입임을 나타냅니다.</p>
						
						<pre>public class MyPipelineAsset : RenderPipelineAsset {

	<ins>protected override IRenderPipeline InternalCreatePipeline () {</ins>
		<ins>return null;</ins>
	<ins>}</ins>
}</pre>
						
						<aside>
							<h3>인터페이스란 무엇인가요?</h3>
							<div>
								<p>인터페이스는 클래스와 유사하지만, 구현을 제공하지 않고 기능의 계약을 정의한다는 점만 다릅니다.  프로퍼티, 이벤트, 인덱서 및 메소드 원형만 제공하며, 당연히 모두 퍼블릭이 됩니다. 인터페이스를 확장하는 모든 타입은 인터페이스가 정의한 원형들에 대한 구현을 포함해야만 합니다. 인터페이스 타입의 이름 앞에는 I를 붙이는 것이 관행입니다.</p>
								
								<p>인터페이스는 구체적인 구현을 포함하지 않기 때문에, 클래스 그리고 구조체도 하나 이상의 인터페이스를 확장할 수 있습니다. 여러 인터페이스가 같은 원형을 정의한 경우, 인터페이스들은 그 기능이 있어야 한다는 것에만 동의합니다.  클래스의 경우에는 추상 클래스라고 하더라도 이것이 불가능합니다. 구현의 충돌로 이어질 수 있기 때문입니다.</p>
							</div>
						</aside>
						
						<p>이제 이 타입의 애셋을 프로젝트에 추가해야 합니다. 이를 가능하게 하려면 <code>MyPipelineAsset</code> 에 <code>CreateAssetMenu</code> 속성을 추가하세요.</p>
						
						<pre><ins>[CreateAssetMenu]</ins>
public class MyPipelineAsset : RenderPipelineAsset {}</pre>
						
						<p>이렇게 하면 <em>Asset / Create</em> 메뉴에 항목이 추가됩니다. 깔끔한 정리를 위해서 <em>Rendering</em> 서브메뉴에 넣으세요. 속성의 <code>nemuName</code> 프로퍼티를 <em>Rendering/My Pipeline</em>으로 설정하면 됩니다. 프로퍼티는 속성 타입 바로 뒤에 둥근 괄호 안에 설정할 수 있습니다.</p>
						
						<pre>[CreateAssetMenu<ins>(menuName = "Rendering/My Pipeline")</ins>]
public class MyPipelineAsset : RenderPipelineAsset {}</pre>
						
						<p>새 메뉴 항목을 사용하여 프로젝트에 애셋을 추가하고, 이름을 <em>My Pipeline</em>으로 하세요.</p>
						
						<figure>
							<img src="creating-a-pipeline/pipeline-asset.png" width="200" height="86">
							<figcaption>파이프라인 애셋과 스크립트</figcaption>
						</figure>
						
						<p>그 다음에 <em>Scriptable Render Pipeline Settings</em>에 지정합니다.</p>
						
						<figure>
							<img src="creating-a-pipeline/asset-in-use.png" width="320" height="90">
							<figcaption>사용중인 애셋</figcaption>
						</figure>
						
						<p>이제 기본 파이프라인을 대체했고 이로인해 몇 가지 변경이 일어납니다. 첫째, 그래픽스 설정에서 많은 옵션이 사라지며, 이는 유니티의 정보 패널에도 언급됩니다. 둘째, 유효한 대체물을 제공하지 않고 기본 파이프라인을 건너뛰었기 때문에, 더 이상 아무것도 렌더링되지 않습니다. 게임 윈도, 씬 윈도, 재질 미리보기는 더 이상 동작하지 않고, 씬 윈도만이 스카이박스를 보여줍니다.  <em>Window / Analysis / Frame Debugger</em>을 통해 프레임 디버거를 열고 활성화하면, 게임 윈도에 아무것도 그려지지 않는 것을 알 수 있습니다.</p>
					</section>
					
					<section>
						<h3>파이프라인 인스턴스</h3>
						
						<p>유효한 파이프라인을 만들려면  <code>IRenderPipeline</code>를 구현하고 렌더링 프로세스를 담당하는 오브젝트 인스턴스를 제공해야 합니다.  그러니 그것을 위해서 클래스를 하나 생성하고, 이름을 <code>MyPipeline</code>으로 하세요.</p>
						
						<pre><ins>using UnityEngine;</ins>
<ins>using UnityEngine.Experimental.Rendering;</ins>

<ins>public class MyPipeline : IRenderPipeline {}</ins></pre>
						
						<p><code>IRenderPipeline</code>을 직접 구현할 수도 있지만, 대신 <code>RenderPipeline</code> 추상 클래스를 확장하는 것이 더 편리합니다. 이 타입은 이미 <code>IRenderPipeline</code>의 기본적인 구현을 제공하고 있어서 기반으로써 사용할 수 있습니다.</p>
						
						<pre>public class MyPipeline : <ins>RenderPipeline</ins> {}</pre>
						
						<p>이제 <code>InternalCreatePipeline</code>에서 <code>MyPipeline</code>의 새 인스턴스를 반환할 수 있습니다. 비록 아직 아무것도 렌더링 하지 않지만 기술적으로는 우리가 유효한 파이프라인을 가지고 있다는 의미가 됩니다.</p>
						
						<pre>	protected override IRenderPipeline InternalCreatePipeline () {
		return <ins>new MyPipeline()</ins>;
	}</pre>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/creating-a-pipeline/creating-a-pipeline.unitypackage" download rel="nofollow">유니티 패키지</a>
				</section>
				
				<section>
					<h2>렌더링</h2>
					
					<p>파이프라인 오브젝트는 매 프레임 렌더링을 처리합니다. 유니티가 하는 일은 파이프라인의 <code>Render</code> 메소드를 호출하면서 콘텍스트와 활성화된 카메라들을 전달하는 것입니다. 이는 게임 윈도 뿐만 아니라 에디터의 씬 윈도 및 재질 미리보기에서도 수행됩니다. 적절하게 설정을 하고, 무엇을 렌더링할지 파악하고, 모든 일을 올바른 순서로 수행하는 것은 우리에게 달려 있습니다.</p>
					
					<section>
						<h3>콘텍스트</h3>
						
						<p><code>RenderPipeline</code>은 <code>IRenderPipeline</code> 인터페이스에 정의된 <code>Render</code> 메소드의 구현을 포함합니다. 첫 번째 인수는 렌더 콘텍스트인데, 이는 <code>ScriptableRenderContext</code> 구조체이며, 네이티브 코드에 대한 파사드(facade) 역할을 합니다. 두 번째 인수는 렌더링이 필요한 모든 카메라를 포함하는 배열입니다.</p>
						<p><code>RenderPipeline.Render</code>는 아무것도 그리지 않지만, 파이프라인 오브젝트가 렌더링에 사용할 수 있는지 여부를 검사합니다. 그렇지 않다면, 예외를 발생시킵니다. 우리는 이 메소드를 오버라이드 하고 이 검사를 유지하기 위해서 부모의 구현을 호출하겠습니다.</p>
						
						<pre>public class MyPipeline : RenderPipeline {

	<ins>public override void Render (</ins>
		<ins>ScriptableRenderContext renderContext, Camera[] cameras</ins>
	<ins>) {</ins>
		<ins>base.Render(renderContext, cameras);</ins>
	<ins>}</ins>
}</pre>
						
						<p>렌더 콘텍스트를 통해서 유니티 엔진에 명령을 실행하여 사물을 렌더링하고 렌더 스테이트를 제어합니다. 가장 간단한 예제 중 하나는 <code>DrawSkyBox</code> 메소드를 호출하여 skybox를 그리는 것입니다.</p>
						
						<pre>		base.Render(renderContext, cameras);

		<ins>renderContext.DrawSkybox();</ins></pre>
						
						<p><code>DrawSkybox</code>는 인수로 카메라가 필요합니다. 단순히 <code>cameras</code>의 첫 번째 요소를 사용하겠습니다. </p>
						
						<pre>		renderContext.DrawSkybox(<ins>cameras[0]</ins>);</pre>
						
						<p>아직도 게임 윈도에서 스카이박스가 보이지 않습니다. 이는 콘텍스트에 전달한 명령들이 버퍼링 되었기 때문입니다.  실제 작업은 <code>Submit</code> 메소드를 통해 실행을 요청한 후에 발생합니다. </p>
						
						<pre>		renderContext.DrawSkybox(cameras[0]);

		<ins>renderContext.Submit();</ins></pre>
						
						<p>마침내 게임 윈도에 스카이박스가 나타났고, 프레임 디버거에서도 보입니다.</p>
						
						<figure>
							<img src="rendering/frame-debugger-skybox.png" width="208" height="34">
							<figcaption>스카이박스가 그려지는 것을 보여주는 프레임 디버거</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>카메라</h3>
						
						<p>카메라의 배열이 전달되는 것은, 씬에 렌더링 될 카메라가 여러 개 있을 수 있기 때문입니다. 다중 카메라 설정의 예에는 분할 화면 멀티 플레이어, 미니 맵 및 백미러가 있습니다. 각 카메라는 별도로 처리해야 합니다.</p>
						
						<p>이 시점에서는 우리의 파이프라인에서 여러 카메라를 지원하는 것은 신경 쓰지 않겠습니다. 단순하게 또 다른 <code>Render</code> 메소드를 만들어서 하나의 카메라에 대해서 동작하게 하겠습니다.  스카이박스를 그리고 서브밋(submit) 하세요. 그래서 우리는 카메라당 한 번씩 서브밋 합니다.</p>
						
						<pre>	<ins>void Render (ScriptableRenderContext context, Camera camera) {</ins>
		<ins>context.DrawSkybox(camera);</ins>

		<ins>context.Submit();</ins>
	<ins>}</ins></pre>
						
						<p><code>cameras</code> 배열의 각 요소에 대해서 새 메소드를 호출하세요. 유니티의 파이프라인도 카메라들에 대해서 루프를 돌 때 이 방법을 사용하므로, 저는 이 경우에 <code>foreach</code> 루프를 사용합니다. </p>
						
						<pre>	public override void Render (
		ScriptableRenderContext renderContext, Camera[] cameras
	) {
		base.Render(renderContext, cameras);

		<del>//renderContext.DrawSkybox(cameras[0]);</del>

		<del>//renderContext.Submit();</del>

		<ins>foreach (var camera in cameras) {</ins>
			<ins>Render(renderContext, camera);</ins>
		<ins>}</ins>
	}</pre>
						
						<aside>
							<h3><code>foreach</code> 는 어떻게 동작합니까?</h3>
							<div>
								<p><code>a</code>가 배열이라고 가정하면, <code>foreach (var e in a) { … }</code> 는 <code>for (int i = 0; i &lt; a.Length; a++) { var e = a[i]; … }</code> 와 같이 동작합니다. 기능적으로 유일하게 다른 점은 이터레이터 변수 <code>i</code>에 접근 할 수 없다는 점입니다.</p>
								
								<p><code>a</code>가 배열이 아니고 열거 가능한 어떤 것이라면, 반복자(Iterator)가 작동하고 임시 오브젝트가 생성될 수 있는데, 이는 피하는 것이 좋습니다. 그러나 배열과 함께 <code>foreach</code>를 사용하는 것은 안전합니다.</p>
								
								<p>배열 요소 변수를 정의하기 위해서 <code>var</code>를 사용하는 것이 일반적이므로 저도 그렇게 사용합니다.  타입은 <code>a</code>의 요소의 타입이 됩니다.</p>
							</div>
						</aside>
						
						<p>카메라의 방향은 현재로서 스카이박스의 렌더링에 영향을 주지 않습니다. 카메라를 <code>DrawSkybox</code>에 넘기고 있지만 스카이박스가 그려져야 하는지를 결정하기 위해서 사용될 뿐이며, 이는 카메라의 클리어 플래그를 통해 제어됩니다.</p>
						
						<p>스카이박스와 전체 씬을 올바르게 렌더링하기 위해서 뷰-투영 행렬을 설정해야 합니다. 변환 행렬은 카메라의 위치와 방향 (뷰 행렬)을 카메라의 원근 혹은 직교투영 (투영행렬)과 결합합니다. 이 행렬은 프레임 디버거에서 볼 수 있습니다. <em>unity_MatrixVP</em>가 그것이고, 무언가를 그릴 때 사용되는 셰이더 프로퍼티 중 하나입니다.</p>
						
						<p>현재, <em>unity_MatrixVP</em> 행렬은 항상 같습니다. 카메라의 프로퍼티를 <code>SetupCameraProperties</code> 메소드를 통해 콘텍스트에 적용해야 합니다. 이 메소드는 행렬뿐 아니라 다른 프로퍼티들도 설정합니다.</p>
						
						<pre>	void Render (ScriptableRenderContext context, Camera camera) {
		<ins>context.SetupCameraProperties(camera);</ins>

		context.DrawSkybox(camera);

		context.Submit();
	}</pre>
						
						<p>이제 스카이박스는 카메라의 프로퍼티를 고려하여 게임 윈도와 씬 윈도에 올바르게 렌더링 됩니다.</p>
					</section>
					
					<section>
						<h3>명령 버퍼</h3>
						
						<p>콘텍스트는 우리가 서브밋할 때까지 실제 렌더링을 지연시킵니다. 서브밋 전에, 나중에 실행할 명령들을 추가하고 콘텍스트를 설정합니다. 스카이박스를 그리는 것과 같은 일부 작업은 전용의 메소드를 통해서 실행할 수 있지만, 다른 명령들은 별도의 명령 버퍼를 통해 간접적으로 전달되어야 합니다.</p>
						
						<p>명령 버퍼는 새로운 <code>CommandBuffer</code> 오브젝트를 생성하여 얻을 수 있으며 <code>UnityEngine.Rendering</code> 네임스페이스에 정의되어 있습니다. 명령 버퍼들은 스크립터블 렌더링 파이프라인이 추가되기 전에 이미 있었기 때문에 실험적인(experimental) 네임스페이스가 아닙니다. 스카이박스를 그리기 전에 버퍼를 생성하세요.</p>
						
						<pre>using UnityEngine;
<ins>using UnityEngine.Rendering;</ins>
using UnityEngine.Experimental.Rendering;

public class MyPipeline : RenderPipeline {

	…

	void Render (ScriptableRenderContext context, Camera camera) {
		context.SetupCameraProperties(camera);

		<ins>var buffer = new CommandBuffer();</ins>

		context.DrawSkybox(camera);

		context.Submit();
	}
}</pre>
						
						<p><code>ExecuteCommandBuffer</code> 메소드를 통해서 콘텍스트에게 버퍼를 실행하라고 지시할 수 있습니다. 다시 한번, 이는 명령들을 바로 실행하는 것이 아니라 콘텍스트의 내부 버퍼로 복사합니다.</p>
						
						<pre>		var buffer = new CommandBuffer();
		<ins>context.ExecuteCommandBuffer(buffer);</ins></pre>
						
						<p>명령 버퍼들은 유니티 엔진의 네이티브 수준에서 명령을 저장할 리소스를 요청합니다. 이런 리소스가 더 이상 필요하지 않으면 즉시 리소스를 해제하는 것이 가장 좋습니다. <code>ExecuteCommandBuffer</code>를 호출한 직후에, 버퍼의 <code>Release</code>메소드를 호출하면 됩니다.</p>
						
						<pre>		var buffer = new CommandBuffer();
		context.ExecuteCommandBuffer(buffer);
		<ins>buffer.Release();</ins></pre>
						
						<p>빈 명령 버퍼를 실행하면 아무 일도 하지 않습니다. 이전에 그려진 것에 의해서 렌더링이 영향을 받지 않게, 렌더 타깃을 지울 수 있도록 그것을 추가했습니다.  이는 명령 버퍼를 통해서 가능하지만, 콘텍스트를 통해서 직접적으로는 불가능합니다.</p>
						
						<p><code>ClearRenderTarget</code>을 호출해서 클리어 명령을 버퍼에 추가할 수 있습니다.  이는 3개의 인수가 필요합니다. 2개의 부울(boolean)과 하나의 색상입니다. 첫 번째 인수는 깊이 정보를 지울지 여부, 두 번째는 색상 정보를 지울지 여부를 제어합니다. 그리고 세 번째는 클리어 색상입니다.  예를 들어, 깊이 데이터를 지우고, 색상 데이터를 무시하고, <code>Color.clear</code>를 클리어 색상으로 사용합시다. </p>
						
						<pre>		var buffer = new CommandBuffer();
		<ins>buffer.ClearRenderTarget(true, false, Color.clear);</ins>
		context.ExecuteCommandBuffer(buffer);
		buffer.Release();</pre>
						
						<p>프레임 디버거는 이제 명령 버퍼가 실행되어 렌더 타깃을 지우는 것을 보여줍니다. 이 경우, Z와 스텐실이 지워지는 것으로 나타났습니다. Z는 깊이 버퍼를 의미하고, 스텐실 버퍼는 항상 지워집니다.</p>
						
						<figure>
							<img src="rendering/frame-debugger-clear-command.png" width="208" height="52">
							<figcaption>깊이와 스텐실 버퍼 지우기</figcaption>
						</figure>
						
						<p>무엇을 지울지는 클리어 플래그와 배경색을 통해서 카메라별로 설정합니다. 렌더 타깃을 어떻게 지울지 하드코딩 하는 대신에 그 정보를 사용할 수 있습니다.</p>
						
						<pre>		<ins>CameraClearFlags clearFlags = camera.clearFlags;</ins>
		buffer.ClearRenderTarget(
			<ins>(clearFlags &amp; CameraClearFlags.Depth) != 0</ins>,
			<ins>(clearFlags &amp; CameraClearFlags.Color) != 0</ins>,
			<ins>camera.backgroundColor</ins>
		);</pre>
						
						<aside>
							<h3>클리어 플래그는 어떻게 동작하나요?</h3>
							<div>
								<p><code>CameraClearFlags</code>는 비트 플래그의 세트로 사용될 수 있는 열거형입니다. 값의 각 비트는 특정 기능을 사용할지 말지를 나타내는 데 사용됩니다.</p>
								
								<p>전체 값의 비트 플래그를 추출하려면, 비트단위 AND 연산자 <code>&amp;</code>를 사용해서 해당 값을 원하는 플래그와 결합하세요. 결과가 0이 아니라면, 플래그는 설정된 것입니다.</p>
							</div>
						</aside>
						
						<p>명령 버퍼에 이름을 지정하지 않았으므로, 디버거에는 기본 이름인 <em>Unnamed command buffer</em>가 표시됩니다. 대신 카메라의 이름을 버퍼의 <code>name</code> 프로퍼티에 지정해서 사용합시다. 이를 위해서 오브젝트 이니셜라이저 문법을 사용하겠습니다. </p>
						
						<pre>		var buffer = new CommandBuffer <ins>{</ins>
			<ins>name = camera.name</ins>
		<ins>}</ins>;</pre>
						
						<figure>
							<img src="rendering/frame-debugger-camera-name.png" width="208" height="52">
							<figcaption>명령 버퍼에 카메라 이름 사용하기</figcaption>
						</figure>
						
						<aside>
							<h3>오브젝트 이니셜라이저 문법은 어떻게 동작하나요?</h3>
							<div>
								<p>우리는 생성자를 호출한 후에 별도 명령문으로 <code>buffer.name = camera.name;</code>과 같이 작성할 수도 있었습니다.  그러나 새 오브젝트를 만들때 생성자의 호출에 코드 블록을 덧붙일 수 있습니다. 그 다음 오브젝트의 인스턴스를 명시적으로 참조할 필요 없이 블록에서 오브젝트의 필드와 프로퍼티를 설정할 수 있습니다. 또한, 이는 인스턴스를 그런 필드와 프로퍼티가 설정된 후에만 사용해야 한다고 명시합니다. 그 외에도, 하나의 명령문만 허용되는 상황에서 다양한 매겨변수를 갖는 생성자들이 없어도 초기화가 가능해집니다.</p>
								
								<p>생성자 호출시 빈 파라미터 리스트를 생략했는데, 이는 오브젝트 이니셜라이저 문법을 사용할 때 허용됩니다.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>컬링</h3>
						
						<p>스카이박스를 렌더링할 수는 있지만 씬에 넣은 오브젝트들은 아직 렌더링할 수 없습니다. 모든 오브젝트를 렌더링 하는 대신에 카메라가 볼 수 있는 것들만 렌더링하겠습니다. 이는 씬의 모든 렌더러로 시작해서 카메라의 뷰 프러스텀(절두체) 바깥에 있는 객체들을 컬링하는 식으로 수행합니다.</p>
						
						<aside>
							<h3>렌더러란 무엇인가요?</h3>
							<div>
								<p>게임 오브젝트에 추가되는 컴포넌트로 게임오브젝트를 렌더링할 수 있는 어떤 것으로 바꿉니다. 일반적으로 <code>MeshRenderer</code> 컴포넌트 입니다.</p>
							</div>
						</aside>
						
						<p>어떤 것을 컬링할 수 있을지 알아내려면 여러 카메라 설정과 행렬을 추적해야 하는데, 이를 위해서 <code>ScriptableCullingParameters</code> 구조체를 사용할 수 있습니다. 우리가 직접 채우는 대신에 <code>CullResult.GetCullingParameters</code> 정적 메소드에게 부탁할 수 있습니다.  입력으로 카메라를 받고 출력으로 컬링 파라미터를 생성합니다. 그러나 파라미터 구조체를 반환하지는 않습니다. 대신, 두 번째 파라미터의 앞에 <code>out</code>을 붙여서 출력 파라미터로 넘겨주어야 합니다. </p>
						
						<pre>	void Render (ScriptableRenderContext context, Camera camera) {
		<ins>ScriptableCullingParameters cullingParameters;</ins>
		<ins>CullResults.GetCullingParameters(camera, out cullingParameters);</ins>

		…
	}</pre>
						
						<aside>
							<h3>왜 <code>out</code>을 붙여줘야 하나요?</h3>
							<div>
								<p>구조체는 값 타입이므로 단순한 값처럼 취급됩니다. 독자적인 오브젝트가 아니며 변수나 필드로 메모리상의 위치에 대한 참조만 가지고 있습니다. 따라서 구조체를 인수로 넘기면 메소드에는 복사본이 전달됩니다. 메소드는 복사본을 변경할 수 있지만 원본에는 아무 영향을 주지 않습니다.</p>
								
								<p>구조체 파라미터가 출력 파라미터로 정의되면 오브젝트 참조처럼 동작하지만 인수가 존재하는 메모리 스택상의 위치를 가리킵니다. 메소드가 인수를 변경하면 복사본이 아닌 원본에 영향을 줍니다.</p>
								
								<p><code>out</code> 키워드는 메소드가 이전 값을 대체해서 올바른 값을 설정할 책임이 있음을 알려줍니다.</p>
							</div>
						</aside>
						
						<p>출력 파라미터 외에도 <code>GetCullingParameters</code>는 유효한 파라미터를 생성할 수 있었는지 여부도 반환합니다.  모든 카메라의 설정이 유효하지는 않으므로 컬링에 사용할 수 없는 잘못된 결과가 나올 수 있습니다. 그래서 실패하면 렌더링할 것이 없으므로 <code>Render</code>를 종료할 수 있습니다.</p>
						
						<pre>		<ins>if (!</ins>CullResults.GetCullingParameters(camera, out cullingParameters)<ins>) {</ins>
			<ins>return;</ins>
		<ins>}</ins></pre>
						
						<p>일단 컬링 파라미터를 구했다면 컬링에 사용할 수 있습니다. 컬링 파라미터와 콘텍스트를 인수로 <code>CullResults.Cull</code> 정적 메소드를 호출하면 됩니다.  결과는 <code>CullResults</code> 구조체이며 무엇이 보이는지에 대한 정보를 갖습니다.</p>
						
						<p>이 경우, 컬링 파라미터를 참조 파라미터로 넘겨야 하므로 앞에 <code>ref</code>를 붙입니다.</p>
						
						<pre>		if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}

		<ins>CullResults cull = CullResults.Cull(ref cullingParameters, context);</ins></pre>
						
						<aside>
							<h3>왜 <code>ref</code>를 붙여야 하나요?</h3>
							<div>
								<p><code>out</code>과 동일하게 동작하지만 이 경우에는 메소드가 어떤 값을 할당할 필요가 없다는 점이 다릅니다. 메소드를 호출하는 쪽에서 먼저 값을 올바르게 초기화 할 책임을 갖습니다. 따라서 입력을 위해 사용될 수도 있고 선택적으로 출력을 위해서 사용될 수 있습니다.</p>
							</div>
						</aside>
						
						
						<aside>
							<h3>왜 <code>ScripatableCullingParameters</code>는 구조체인가요?</h3>
							<div>
								<p>아마도 최적화를 위한 것으로 메모리 할당에 대해서 걱정할 필요 없이 여러 파라미터 구조체를 만들 수 있게 하려는 생각이었을 겁니다. 그러나, <code>ScriptableCullingParameters</code>는 구조체로 만들기에는 매우 큽니다. 그래서 또 한 번 성능상의 이유로 여기서는 참조 파라미터로 사용됩니다. 어쩌면 처음에는 작았는데 점점 더 커다란 구조체가 되었을지도 모릅니다. 재사용 가능한 오브젝트 인스턴스가 더 나은 접근방식일 수도 있지만 우리는 유니티가 결정한 방식으로 작업을 할 수 밖에 없습니다.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>드로잉</h3>
						
						<p>무엇이 보이는지 알았다면 그 형체들을 렌더링할 수 있습니다. 어떤 렌더러를 사용할지 알려주기 위해서 인수로 <code>cull.visibleRenderers</code>를 넘겨서 콘텍스트의 <code>DrawRenders</code>을 호출하면 됩니다. 그 외에도, 드로잉 설정과 필터 설정을 제공해야합니다. <code>DrawRendererSettings</code>와 <code>FilterRenderersSettings</code> 둘 다 구조체입니다. 처음에는 기본값을 사용하겠습니다. 드로잉 설정은 참조로 전달해야 합니다.</p>
						
						<pre>		buffer.Release();

		<ins>var drawSettings = new DrawRendererSettings();</ins>

		<ins>var filterSettings = new FilterRenderersSettings();</ins>

		<ins>context.DrawRenderers(</ins>
			<ins>cull.visibleRenderers, ref drawSettings, filterSettings</ins>
		<ins>);</ins>

		context.DrawSkybox(camera);</pre>
						
						<aside>
							<h3>왜 <code>FilterRendererSettings</code>가 아니라 <code>FilterRenderersSettings</code> 인가요?</h3>
							<div>
								<p>모르겠습니다. 어쩌면 오타일 수도 있습니다. </p>
							</div>
						</aside>
						
						<p>기본 필터 설정에는 아무것도 포함되어 있지 않으므로 아직은 아무런 오브젝트도 볼 수 없습니다. 대신 <code>FilterRenderersSettings</code> 생성자의 인수로 <code>true</code>를 제공함으로써 모든 것을 포함할 수 있습니다. 이는 모든 것을 포함하도록 초기화하라고 지시합니다.</p>
						
						<pre>		var filterSettings = new FilterRenderersSettings(<ins>true</ins>);</pre>
						
						<p>또한 카메라와 셰이더 패스를 생성자의 인수로 제공하여 드로잉 설정을 해야 합니다. 카메라는 정렬 및 컬링 레이어 설정에 사용되는 반면, 패스는 렌더링에 어떤 셰이더 패스를 사용할지 제어합니다.</p>
						
						<p>셰이더 패스는 문자열을 통해 구별되고 <code>ShaderPassName</code>  구조체에 래핑되어야 합니다. 우리 파이프라인은 언릿 재질만 지원하므로 <em>SRPDefaultUnlit</em>으로 식별되는 유니티의 기본 언릿 패스를 사용하겠습니다.</p>
						
						<pre>		var drawSettings = new DrawRendererSettings(
			<ins>camera, new ShaderPassName("SRPDefaultUnlit")</ins>
		);</pre>
						
						<figure>
							<img src="rendering/opaque-only.jpg" width="250" height="90">
							<figcaption>불투명한 구가 보임</figcaption>
						</figure>
						
						<p>불투명한 언릿 형체들은 보이기 시작하지만 투명한 것들은 보이지 않습니다. 그러나, 프레임 디버거는 그 언릿 형체들도 그려지고 있다고 표시합니다.</p>
						
						<figure>
							<img src="rendering/frame-debugger-draw.png" width="250" height="130">
							<figcaption>모든 언릿 렌더러가 그려짐</figcaption>
						</figure>
						
						<p>그려지고는 있지만 투명 셰이더 패스에서 깊이 버퍼에 쓰지 않기 때문에 스카이박스에 의해서 덮어서 그려지게 됩니다. 해결 방법은 스카이박스가 그려질 때까지 투명한 렌더러의 드로잉을 지연시키는 것입니다.</p>
						
						<p>우선, 스카이박스 앞쪽의 드로잉을 불투명한 렌더러로 제한하세요. 필터 설정의 <code>renderQueueRange</code>를 <code>RenderQueueRange.opaque</code>로 설정하면 되며, 이는 0에서 2500 까지의 렌더 큐를 포함합니다. </p>
						
						<pre>		var filterSettings = new FilterRenderersSettings(true) <ins>{</ins>
			<ins>renderQueueRange = RenderQueueRange.opaque</ins>
		<ins>}</ins>;</pre>
						
						<figure>
							<img src="rendering/frame-debugger-opaque.png" width="250" height="98">
							<figcaption>불투명한 렌더러만 그려짐.</figcaption>
						</figure>
						
						<p>다음으로, 스카이박스를 렌더링한 후에 큐의 범위를  <code>RenderQueueRange.transparent</code> (2501에서 5000까지) 로 바꿔서 다시 렌더링합니다.</p>
						
						<pre>		var filterSettings = new FilterRenderersSettings(true) {
			renderQueueRange = RenderQueueRange.opaque
		};

		context.DrawRenderers(
			cull.visibleRenderers, ref drawSettings, filterSettings
		);

		context.DrawSkybox(camera);

		<ins>filterSettings.renderQueueRange = RenderQueueRange.transparent;</ins>
		<ins>context.DrawRenderers(</ins>
			<ins>cull.visibleRenderers, ref drawSettings, filterSettings</ins>
		<ins>);</ins></pre>
						
						<figure>
							<img src="rendering/opaque-then-transparent.jpg" width="250" height="100" alt="씬"><br>
							<img src="rendering/frame-debugger-transparent.png" width="250" height="146" alt="프레임 디버거">
							<figcaption>불투명, 스카이박스, 그리고 나서 투명.</figcaption>
						</figure>
						
						<p>오버드로우를 방지하기 위해서 스카이박스 앞에 불투명한 렌더러들을 그립니다. 형체들이 항상 스카이박스 앞에 있기 때문에 형체들을 먼저 그림으로써 오버드로우를 피합니다.  이는 불투명한 셰이더 패스가 깊이 버퍼에 쓰기 때문이며 깊이 버퍼는 나중에 그려지는 더 멀리 있는 것들을 건너뛰는데 사용됩니다.</p>
						
						<p>하늘 일부를 가리는 것 외에도 불투명한 렌더러들은 서로를 가리게 될 수도 있습니다. 이상적으로는, 프레임 버퍼의 각 프래그먼트에 대해서 카메라에서 가장 가까운 것들만 그려집니다. 오버드로우를 최대한 줄이려면 가장 가까운 형체를 먼저 그려야 합니다. 드로잉 전에 렌더러들을 정렬하는 방법으로 가능하고, 이는 정렬 플래그를 통해 제어됩니다.</p>
						
						<p>드로잉 설정은 <code>DrawRendererSortSettings</code> 타입의 <code>sorting</code> 구조체를 포함하고, 이는 정렬 플래그를 포함합니다. 불투명한 형체들을 그리기 전에 <code>SortFlags.CommonOpaque</code>로 설정하세요.  이는 유니티가 렌더러들을 거리 (앞에서 뒤로) 및 추가적인 몇 가지 기준에 의해서 정렬하도록 지시합니다.</p>
						
						<pre>		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("SRPDefaultUnlit")
		);
		<ins>drawSettings.sorting.flags = SortFlags.CommonOpaque;</ins></pre>
						
						<p>그러나 투명한 렌더링은 다르게 작동합니다. 이전에 그려진 색과 지금 그려지는 색을 결합해서 결과가 투명하게 나타납니다. 이는 뒤에서 앞으로 반대의 순서로 그리는 것을 필요로 합니다. 이를 위해 <code>SortFlags.CommonTransparent</code>를 사용할 수 있습니다.</p>
						
						<pre>		context.DrawSkybox(camera);

		<ins>drawSettings.sorting.flags = SortFlags.CommonTransparent;</ins>
		filterSettings.renderQueueRange = RenderQueueRange.transparent;
		context.DrawRenderers(
			cull.visibleRenderers, ref drawSettings, filterSettings
		);</pre>
						
						<p>우리의 파이프라인은 이제 불투명 및 투명 언릿 오브젝트를 제대로 렌더링할 수 있습니다.</p>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-pipeline/rendering/rendering.unitypackage" download rel="nofollow">유니티 패키지</a>
				</section>
				
				<section>
					<h2>다듬기</h2>
					
					<p>올바르게 렌더링할 수 있다는 것은 온전하게 동작하는 파이프라인의 일부일 뿐입니다.  충분히 빠른지, 불필요한 임시 오브젝트를 할당하지 않는지, 유니티 에디터와 잘 통합돠는지 등 고려해야 할 것이 더 있습니다. </p>
					
					<section>
						<h3>메모리 할당</h3>
						
						<p>우리의 파이프라인이 메모리 관리 측면에서 잘 작동하는지, 또는 매 프레임 메모리를 할당해서 가비지 컬렉션이 자주 발생하는지 확인해 봅시다. <em>Window / Analysis / Profiler</em>를 통해 프로파일러를 열고 <em>Hierarchy</em> 모드에서 <em>CPU Usage</em> 데이터를 점검하면 됩니다.  에디터에서 플레이 모드로 할 수도 있지만, 개발 빌드를 만들고 프로파일러에 자동으로 연결하게 해서, 빌드를 프로파일 하는 것도 좋은 생각입니다. 다만 이 경우 딥 프로파일링은 불가능합니다. (역자 주: 2017.3부터는 안드로이드에서 딥 프로파일링이 가능합니다. https://unity3d.com/learn/tutorials/topics/best-practices/unity-profiler)</p>
						
						<p><em>GC Alloc</em>을 기준으로 정렬하면 메모리가 실제로 매 프레임 할당되는 것을 볼 수 있습니다.  그중 일부는 우리가 제어할 수 없지만, 꽤 많은 바이트가 우리 파이프라인의 <code>Render</code> 메소드 안에서 할당됩니다.</p>
						
						<p>컬링이 대부분의 메모리를 할당하는 것으로 밝혀졌습니다. 그 이유는 <code>CullResults</code>가 구조체이지만 3개의 리스트를 가졌고, 이 리스트들이 오브젝트이기 때문입니다. 매번 우리가 새로운 컬링 결과를 요구할 때마다 새 리스트들을 위해서 메모리를 할당하게 됩니다. 그래서 <code>CullResults</code>가 구조체이기 때문에 얻는 이점이 크지 않습니다.</p>
						
						<p>다행히도, <code>CullResults</code>는 대체 가능한 <code>Cull</code> 메소드가 있으며 이 메소드는 새 구조체를 반환하는 대신에 참조 파라미터로 구조체를 받습니다.  이렇게 하면 리스트들의 재사용이 가능해집니다. <code>cull</code> 을 필드로 바꾸고, 그것에 대입하는 대신에 <code>CullResults.Cull</code>의 인수로 추가해 주기만 하면 됩니다.</p>
						
						<pre>	<ins>CullResults cull;</ins>

	…

	void Render (ScriptableRenderContext context, Camera camera) {
		…

		<del>//CullResults cull = CullResults.Cull(ref cullingParameters, context);</del>
		<ins>CullResults.Cull(ref cullingParameters, context, ref cull);</ins>
		
		…
	}</pre>
						
						<p>연속적인 메모리 할당의 또 다른 원인은 카메라 이름 프로퍼티의 사용에 있습니다. 매번 그 값을 얻을 때마다 네이티브 코드에서 이름을 가져오므로 새 문자열을 생성해야 하고, 문자열은 오브젝트입니다. 그러니 대신에 <em>Render Camera</em>를 우리의 명령 버퍼의 이름으로 사용합시다.</p>
						
						<pre>		var buffer = new CommandBuffer() {
			name = <ins>"Render Camera"</ins>
		};</pre>
						
						<figure>
							<img src="polishing/constant-buffer-name.png" width="250" height="82">
							<figcaption>고정된 버퍼 이름 사용</figcaption>
						</figure>
						
						<p>마지막으로, 명령 버퍼 자체도 오브젝트 입니다. 다행히, 명령 버퍼를 한 번 만들어서 재사용할 수 있습니다. 지역 변수를 <code>cameraBuffer</code> 필드로 교체하세요. 오브젝트 초기화 문법 덕분에 이름있는 명령 버퍼를 기본값으로 만들 수 있습니다. 마지막 변경사항은 명령 버퍼를 해제하는 대신 <code>Clear</code> 메소드를 사용해 지워주는 것입니다.</p>
						
						<pre>	<ins>CommandBuffer cameraBuffer = new CommandBuffer {</ins>
		<ins>name = "Render Camera"</ins>
	<ins>};</ins>

	…

	void Render (ScriptableRenderContext context, Camera camera) {
		…

		<del>//var buffer = new CommandBuffer() {</del>
		<del>//	name = "Render Camera"</del>
		<del>//};</del>
		<ins>cameraBuffer</ins>.ClearRenderTarget(true, false, Color.clear);
		context.ExecuteCommandBuffer(<ins>cameraBuffer</ins>);
		<del>//buffer.Release();</del>
		<ins>cameraBuffer.Clear();</ins>

		…
	}</pre>
						
						<p>이런 변경 후에 우리의 파이프라인은 더 이상 매 프레임에 임시 오브젝트를 생성하지 않습니다.</p>
					</section>
					
					<section>
						<h3>프레임 디버거 샘플링</h3>
						
						<p>우리가 더 해볼 수 있는 것은 프레임 디버거에 표시되는 데이터를 개선하는 것입니다. 유니티의 파이프라인은 이벤트의 중첩된 계층 구조를 보여주지만, 우리의 파이프라인은 모두 최상위 단계에 있습니다.   명령 버퍼를 사용해서 프로파일러 샘플을 시작하고 끝내는 방식으로 계층 구조를 만들 수 있습니다.</p>
						
						<p><code>ClearRenderTarget</code> 바로 앞에서 <code>BeginSample</code>을 호출하는 것으로 시작해서, 곧 바로<code>EndSample</code>을 호출합시다. 모든 샘플은 시작과 끝을 가져야 하며 둘 다 정확히 같은 이름으로 제공되어야 합니다.  이 외에도, 샘플링을 정의하는 명령 버퍼와 동일한 이름을 사용하는 것이 가장 좋습니다.  명령 버퍼의 이름은 종종 사용됩니다.</p>
						
						<pre>		<ins>cameraBuffer.BeginSample("Render Camera");</ins>
		cameraBuffer.ClearRenderTarget(true, false, Color.clear);
		<ins>cameraBuffer.EndSample("Render Camera");</ins>
		context.ExecuteCommandBuffer(cameraBuffer);
		cameraBuffer.Clear();</pre>
						
						<figure>
							<img src="polishing/sampling.png" width="250" height="98">
							<figcaption>샘플링이 계층 구조를  만듭니다.</figcaption>
						</figure>
						
						<p><em>Render Camera</em> 단계가 명령 버퍼의 기존 <em>Render Camera</em> 안쪽으로 들어가 있고, 이어서 지우기 연산이 그 안으로 들어간 것을 볼 수 있습니다.  그러나 한 단계 더 나아가서 카메라와 관련된 모든 동작도 그 안에 넣을 수 있습니다. 이를 위해서는 콘텍스트를 서브밋 하기 직전까지 샘플의 종료를 지연해야 합니다. 그래서 그 시점에 추가로 샘플을 끝내는 명령만을 포함한 <code>ExecuteCommandBuffer</code>를 넣어야 합니다. 같은 명령 버퍼를 사용하고 작업이 끝난 후 다시 지우세요.</p>
						
						<pre>		cameraBuffer.BeginSample("Render Camera");
		cameraBuffer.ClearRenderTarget(true, false, Color.clear);
		<del>//cameraBuffer.EndSample("Render Camera");</del>
		context.ExecuteCommandBuffer(cameraBuffer);
		cameraBuffer.Clear();

		…

		<ins>cameraBuffer.EndSample("Render Camera");</ins>
		<ins>context.ExecuteCommandBuffer(cameraBuffer);</ins>
		<ins>cameraBuffer.Clear();</ins>

		context.Submit();</pre>
						
						<figure>
							<img src="polishing/nested-sampling.png" width="250" height="98">
							<figcaption>중첩된 샘플링</figcaption>
						</figure>
						
						<p>다른 모든 동작은 최상위 단계의 바로 밑에 있는 반면에 지우기 동작만 중복되는 <em>Render Camera</em> 단계의 안쪽에 포함되는 점을 제외하면 좋아 보입니다.  왜 이런 일이 발생하는지 확신할 수 없지만 지운 후에 샘플을 시작하는 것으로 이 문제를 피할 수 있습니다. </p>
						
						<pre>		<del>//cameraBuffer.BeginSample("Render Camera");</del>
		cameraBuffer.ClearRenderTarget(true, false, Color.clear);
		<ins>cameraBuffer.BeginSample("Render Camera");</ins>
		context.ExecuteCommandBuffer(cameraBuffer);
		cameraBuffer.Clear();</pre>
						
						<figure>
							<img src="polishing/without-redundancy.png" width="250" height="84">
							<figcaption>반복되는 중첩이 없음. </figcaption>
						</figure>
					</section>
					
					<section>
						<h3>기본 파이프라인의 렌더링</h3>
						
						<p>우리의 파이프라인은 언릿 셰이더만 지원하기 때문에 다른 셰이더를 사용하는 오브젝트는 렌더링 되지 않으므로 그 오브젝트들이 보이지 않게 됩니다.  올바른 동작이지만, 이는 일부 오브젝트가 잘못된 셰이더를 사용한다는 사실을 숨깁니다. 유니티의 에러 셰이더로 그러한 오브젝트를 시각화해서 명백히 잘못된 마젠타 형체로 나타나게 된다면 좋을 것 같습니다. 이를 위해 콘텍스트와 카메라 파라미터를 사용하여 전용의 <code>DrawDefaultPipeline</code> 메소드를 추가해 보겠습니다. 투명한 형체들을 그린 후에 마지막에 호출하겠습니다.</p>
						
						<pre>	void Render (ScriptableRenderContext context, Camera camera) {
		…

		drawSettings.sorting.flags = SortFlags.CommonTransparent;
		filterSettings.renderQueueRange = RenderQueueRange.transparent;
		context.DrawRenderers(
			cull.visibleRenderers, ref drawSettings, filterSettings
		);

		<ins>DrawDefaultPipeline(context, camera);</ins>

		cameraBuffer.EndSample("Render Camera");
		context.ExecuteCommandBuffer(cameraBuffer);
		cameraBuffer.Clear();

		context.Submit();
	}

	<ins>void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {}</ins></pre>
						
						<p>유니티의 기본 서피스 셰이더는 첫 번째 포워드 렌더링 패스로 사용되는 <em>ForwardBase</em> 패스를 갖습니다.  이를 활용해서 오브젝트가 기본 파이프라인과 함께 작동하는 재질을 가졌는지 식별할 수 있습니다.  새로운 드로잉 설정을 통해서 해당 패스를 선택하고 렌더링을 위해 새로운 기본 필터 설정과 함께 사용하세요. 정렬이나 투명과 불투명 렌더러를 구분하는 것은 신경쓰지 않습니다. 어차피 올바르지 않은 경우이기 때문입니다.</p>
						
						<pre>	void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {
		<ins>var drawSettings = new DrawRendererSettings(</ins>
			<ins>camera, new ShaderPassName("ForwardBase")</ins>
		<ins>);</ins>
		
		<ins>var filterSettings = new FilterRenderersSettings(true);</ins>
		
		<ins>context.DrawRenderers(</ins>
			<ins>cull.visibleRenderers, ref drawSettings, filterSettings</ins>
		<ins>);</ins>
	}</pre>
						
						<figure>
							<img src="polishing/forward-base-pass.jpg" width="250" height="98">
							<figcaption>포워드 베이스 패스의 렌더링</figcaption>
						</figure>
						
						<p>이제 기본 셰이더를 사용하는 오브젝트가 나타납니다. 프레임 디버거에서도 보입니다.</p>
						
						<figure>
							<img src="polishing/frame-debugger-forward-base.png" width="288" height="210">
							<figcaption>모든 것이 그려집니다.</figcaption>
						</figure>
						
						<p>우리의 파이프라인은 포워드 베이스 패스를 지원하지 않기 때문에 올바르게 렌더링 되지 않습니다.  필요한 데이터가 설정되지 않았으므로 라이팅에 의존하는 모든 것이 검은색이 되어 버립니다. 대신, 에러 셰이더를 사용해 렌더링 해야 합니다.  이렇게 하려면 에러 재질이 필요합니다. 그것을 위해서 필드를 추가하세요. 그 다음, <code>DrawDefaultPipeline</code>의 시작 부분에서 에러 재질이 아직 존재하지 않는다면 에러 재질을 생성하세요. <code>Shader.Find</code>를 통해 <em>Hidden/InternalErrorShader</em>를 얻은 다음에 그 셰이더로 새 재질을 만들면 됩니다. 또한, 재질의 숨김 플래그를 <code>HideFlags.HideAndDontSave</code>로 만들어서 프로젝트 윈도에도 보이지 않고 다른 모든 애셋과 함께 저장되지 않도록 하세요.</p>
						
						<pre>	<ins>Material errorMaterial;</ins>

	…

	void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {
		<ins>if (errorMaterial == null) {</ins>
			<ins>Shader errorShader = Shader.Find("Hidden/InternalErrorShader");</ins>
			<ins>errorMaterial = new Material(errorShader) {</ins>
				<ins>hideFlags = HideFlags.HideAndDontSave</ins>
			<ins>};</ins>
		<ins>}</ins>
		
		…
	}</pre>
						
						<p>드로잉 설정에는 <code>SetOverrideMaterial</code>을 호출해서 렌더링에 사용될 재질을 재정의하는 옵션이 있습니다. 첫 번째 파라미터는 사용할 재질입니다. 두 번째 파라미터는 렌더링에 사용될 재질의 셰이더 패스의 인덱스입니다. 에러 셰이더는 단일 패스만 가지므로 0을 사용하세요.</p>
						
						<pre>		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("ForwardBase")
		);
		<ins>drawSettings.SetOverrideMaterial(errorMaterial, 0);</ins></pre>
						
						<figure>
							<img src="polishing/error-material.jpg" width="250" height="98">
							<figcaption>에러 셰이더의 사용</figcaption>
						</figure>
						
						<p>지원하지 않는 재질을 사용하는 오브젝트들은 이제 확실히 잘못된 것처럼 보입니다. 그러나 이는 쉐이더들이 <code>ForwardBase</code> 패스를 갖는 유니티의 기본 파이프라인의 재질들에만 해당합니다. 다른 패스로 식별할 수 있는 내장 셰이더가 있습니다.  특별히 <em>PrepassBase</em>, <em>Always</em>, <em>Vertex</em>, <em>VertexLMRGBM</em>, <em>VertexLM</em>등이 있습니다.</p>
						
						<p>다행히도, <code>SetShaderPassName</code>을 호출해서 드로잉 설정에 여러 패스를 추가할 수 있습니다. 이름은 이 메소드의 두 번째 파라미터입니다. 첫 번째 파라미터는 해당 패스가 그려지는 순서를 제어하는 인덱스입니다. 어떤 순서로 그려지든 상관이 없으므로 아무 순서나 넣어도 좋습니다. 생성자를 통해 제공된 패스는 언제나 인덱스 0을 갖습니다. 추가적인 패스를 위해 인덱스를 하나씩 증가시킵니다.</p>
						
						<pre>		var drawSettings = new DrawRendererSettings(
			camera, new ShaderPassName("ForwardBase")
		);
		<ins>drawSettings.SetShaderPassName(1, new ShaderPassName("PrepassBase"));</ins>
		<ins>drawSettings.SetShaderPassName(2, new ShaderPassName("Always"));</ins>
		<ins>drawSettings.SetShaderPassName(3, new ShaderPassName("Vertex"));</ins>
		<ins>drawSettings.SetShaderPassName(4, new ShaderPassName("VertexLMRGBM"));</ins>
		<ins>drawSettings.SetShaderPassName(5, new ShaderPassName("VertexLM"));</ins>
		drawSettings.SetOverrideMaterial(errorMaterial, 0);</pre>
						
						<p>이 정도면 지금까지 유니티에 의해 제공된 모든 셰이더를 포함할 수 있고, 씬 생성시 잘못된 재질의 사용을 지적하기에는 충분할 겁니다. 그러나 개발 과정에서만 이 작업이 필요한 것이지 빌드에서는 필요하지 않습니다. 그러니 에디터에서만 <code>DrawDefaultPipeline</code>을 호출합시다.  이를 위한 방법의 하나는 <code>Conditional</code> 속성을 메소드에 추가하는 것입니다.</p>
					</section>
					
					<section>
						<h3>조건부 코드 실행</h3>
						
						<p><code>Conditional</code> 속성은 <code>System.Diagnostics</code> 네임스페이스에 정의되어 있습니다. 그 네임스페이스를 사용할 수 있지만 불행히도 거기에는 <code>Debug</code> 타입도 포함되어 있어서 <code>UnityEngine.Debug</code>와 충돌합니다. 우리는 해당 속성만 필요하므로 별칭을 사용해서 충돌을 피할 수 있습니다. 전체 네임스페이스를 사용하는 대신 특정 타입을 사용하고 그 타입에 유효한 이름을 할당합니다. 이 경우, 우리는 <code>System.Diagnostics.ConditaionalAttribute</code>의 별칭으로 <code>Conditional</code>을 정의하겠습니다.</p>
						
						<pre>using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;
<ins>using Conditional = System.Diagnostics.ConditionalAttribute;</ins></pre>
						
						<p>속성을 우리의 메소드에 추가하세요. 심볼을 지정하는 문자열 인수가 필요합니다. 컴파일 중에 해당 심볼이 정의되어 있으면 메소드 호출은 정상적으로 포함이 됩니다. 그러나 만약 심볼이 정의되어 있지 않다면 모든 인자와 함께 이 메소드의 호출은 제거됩니다. 마치 컴파일 중에 <code>DrawDefaultPipeline(context, camera);</code> 코드가 없었던 것과 같이 됩니다.</p>
						
						<p>유니티 에디터용으로 컴파일할 때만 이 호출을 포함하려면 <em>UNITY_EDITOR</em> 심볼을 사용해야 합니다.</p>
						
						<pre>	<ins>[Conditional("UNITY_EDITOR")]</ins>
	void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {
		…
	}</pre>
						
						<p>한 걸음 더 나아가서 개발 빌드에도 이 호출을 포함할 수 있으며 이는 릴리즈 빌드에서만 호출을 제외하게 됩니다. 그렇게 하려면, <em>DEVELOPMENT_BUILD</em> 심볼과 함께 추가적인 조건을 추가하세요.</p>
						
						<pre>	[<ins>Conditional("DEVELOPMENT_BUILD"),</ins> Conditional("UNITY_EDITOR")]
	void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {
		…
	}</pre>
					</section>
					
					<section>
						<h3>씬 윈도에서의 UI</h3>
						
						<p>한 가지 지금까지 고려하지 못한 것은 유니티의 인게임 UI 입니다. 테스트를 위해서 씬에 UI 요소를 추가하세요. 예를 들어, <em>GameObject / UI / Button</em>을 통해 버튼 하나를 추가해보세요. 버튼이 들어있는 캔버스와 이벤트 시스템이 만들어집니다.</p>
						
						<p>우리가 아무것도 하지 않아도 UI가 게임 윈도안에 렌더링 되는 것으로 밝혀졌습니다.  유니티가 알아서 해줍니다. 프레임 디버거는 UI가 오버레이로 별도로 렌더링되는 것을 보여줍니다. </p>
						
						<figure>
							<img src="polishing/frame-debugger-ui-screen.png" width="250" height="162">
							<figcaption>UI가 스크린 스페이스에 그려집니다.</figcaption>
						</figure>
						
						<p>적어도, 캔버스가 스크린 스페이스에 렌더링되도록 설정된 경우입니다. 월드 스페이스에 렌더링하도록 설정된 경우, UI가 다른 투명한 오브젝트들과 함께 렌더링됩니다.</p>
						
						<figure>
							<img src="polishing/frame-debugger-ui-world.png" width="286" height="260">
							<figcaption>월드 스페이스의 UI</figcaption>
						</figure>
						
						<p>UI가 게임 윈도에서는 동작하지만 씬 윈도에는 나타나지 않습니다. 씬 윈도에서 UI는 항상 월드 스페이스에 존재하지만 수동으로 씬에 삽입해야 합니다. UI를 추가하기 위해서는 현재 카메라를 인수로 해서 <code>ScriptableRenderContext.EmitWorldGeometryForSceneView</code> 정적 메소드를 호출하면 됩니다.  컬링 전에 수행되어야 합니다.</p>
						
						<pre>		if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}

		<ins>ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);</ins>

		CullResults.Cull(ref cullingParameters, context, ref cull);</pre>
						
						<p>그러나 이것은 게임 윈도에 UI를 두 번 추가합니다. 이를 방지하려면, 씬 윈도를 렌더링할 때만 UI 지오메트리를 내보내야 합니다.  이는 카메라의 <code>cameraType</code>이 <code>CameraType.SceneView</code>와 같은 경우입니다.</p>
						
						<pre>		<ins>if (camera.cameraType == CameraType.SceneView) {</ins>
			ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);
		<ins>}</ins></pre>
						
						<p>이 코드는 동작하기는 하지만 에디터 안에서만 동작합니다. 조건부 컴파일에 의해서 빌드용으로 컴파일할 때는 <code>EmitWorldGeometryForSceneView</code>가 존재하지 않게 되고, 이제 빌드를 하려고 하면 컴파일 에러가 발생한다는 의미입니다. 다시 작동하게 하려면 <code>EmitWorldGeometryForSceneView</code> 역시 조건부로 호출하도록 코드를 작성해야 합니다. 코드를 <code>#if</code>와 <code>#endif</code>문 사이에 넣으면 됩니다. <code>#if</code> 문은 <code>Conditional</code> 속성과 마찬가지로 심볼을 필요로 합니다. <em>UNITY_EDITOR</em> 를 사용함으로써 코드는 에디터용으로 컴파일할 때만 포함됩니다.</p>
						
						<pre>	void Render (ScriptableRenderContext context, Camera camera) {
		ScriptableCullingParameters cullingParameters;
		if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {
			return;
		}

<ins>#if UNITY_EDITOR</ins>
		if (camera.cameraType == CameraType.SceneView) {
			ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);
		}
<ins>#endif</ins>

		CullResults.Cull(ref cullingParameters, context, ref cull);

		…
	}</pre>
						
						<p>다음 튜토리얼은 <a href="../custom-shaders/index.html">커스텀 쉐이더</a>입니다.</p>
					</section>
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/scriptable-render-pipeline-01-custom-pipeline/" class="repository">repository</a>
					<a href="Custom-Pipeline.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p><a href="https://catlikecoding.com/unity/tutorials/">튜토리얼</a>을 즐기고 계세요? 유용한가요? 더 보고 싶으세요?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Patreon에서 저를 지원해주세요!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="저의 후원자가 되어 주세요!" width="217" height="51"></a></p>
			<p><b><a href="https://catlikecoding.com/unity/tutorials/donating.html">혹은 직접 기부해 주세요</a>!</b></p>
			<p><a href="https://catlikecoding.com/jasper-flick/" rel="author">Jasper Flick</a>에 의해 작성되었습니다</p>
		</footer>
		
		<script src="../../jquery.js"></script>
		<script src="../../tutorials.js"></script>
	</body>
</html>