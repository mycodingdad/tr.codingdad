Catlike Coding › Unity › Tutorials › Scriptable Render Pipeline Custom Pipeline Taking Control of Rendering Create a pipeline asset and instance. 컬링, 필터링, 정렬, 렌더링. 메모리를 깨끗하게 유지하기 좋은 편집 경험을 제공하기 This is the first installment of a tutorial series covering Unity's scriptable render pipeline. This tutorial assumes you've gone through the Basics series first, and the Procedural Grid tutorial. The first few parts of the Rendering series are also useful. 이 튜토리얼은 유니티 2018.3.0f2를 사용하여 작성되었습니다. 새로운 렌더 파이프라인의 탄생 1 Creating a Pipeline To render anything, Unity has to determine what shapes have to be drawn, where, when, and with what settings. This can get very complex, depending on how many e!ects are involved. Lights, shadows, transparency, image e!ects, volumetric e!ects, and so on all have to be dealt with in the correct order to arrive at the final image. 이 과정이 렌더 파이프라인이라고 알려져 있습니다. 유니티 2017은 두 개의 미리 정의된 렌더 파이프라인을 지원하는데 하나는 포워드 렌더링이고 다른 하나는 디퍼드(지연된) 렌더링입니다. 유니티 5에서 소개되었던 오래된 디퍼드 렌더링도 여전히 지원합니다. 이런 파이프라인들은 고정되어 있습니다. 파이프라인의 특정 부분을 활성화, 비활성화, 오버라이드 할 수 있지만, 유니티의 설계에서 크게 벗어날 수는 없습니다.  유니티 2018은 스크립터블 렌더 파이프라인에 대한 지원을 추가하여 처음부터 새로 파이프라인을 설계할 수 있게 하였지만 컬링과 같은 여러 개별적인 단계에서는 여전히 유니티에 의존해야 합니다.  유니티 2018에서는 이런 방식으로 만들어진 두 개의 새로운 파이프라인이 소개되었습니다. 경량(lightweight) 파이프라인과 고화질(high-definition) 파이프라인입니다.  두 파이프라인 모두 아직 프리뷰 단계이고 스크립터블 렌더 파이프라인 API도 아직 실험적인 기술로 표시되어 있습니다.  그러나 이 시점에서도 자체적인 파이프라인을 만들기에는 충분히 안정적입니다.  이 튜토리얼에서 우리는 라이팅 되지 않은(unlit) 형체들을 그리는 최소한의 렌더 파이프라인을 구성하겠습니다. 일단 파이프라인이 동작하면, 라이팅, 그림자 및 고급 기능들을 넣으면서 이어지는 튜토리얼에서 파이프라인을 확장할 수 있습니다.  1.1 Project Setup Open Unity 2018 and create a new project. 저는 유니티 2018.2.9f1을 사용중이지만, 2018.2 버전 이상이라면 잘 동작합니다. 애널리틱스를 비활성화한 표준 3D 프로젝트를 만드세요. 우리는 우리만의 파이프라인을 만들 예정이니 파이프라인 옵션은 선택하지 마세요. Once the project is open, go the package manager via Window / Package Manager and remove all the packages that were included by default, as we won't need them. Only keep the Package Manager UI, which cannot be removed. 프로젝트 시작하기. 선형 색 공간에서 작업할 예정인데, 유니티 2018은 아직 감마 공간을 기본으로 사용합니다. So go to the player settings via Edit / Project Settings / Player and switch Color Space in the Other Settings section to Linear. 선형 색 공간 우리의 파이프라인을 테스트하기 위해서 몇 개의 간단한 재질이 필요할 겁니다. 네 개의 재질을 만들었습니다. 첫 번째, 빨간색의 기본 스탠다드 불투명 재질. Second, the same material but with Rendering Mode set to Transparent and a blue albedo with decreased alpha. Third, a material using the Unlit/Color shader with its color set to yellow. And finally a material using the Unlit/Transparent shader without any changes, so it appears solid white. 테스트 재질들 네 개의 재질들 모두를 사용해서, 몇 개의 오브젝트로 씬을 채우세요. 네 개의 재질들을 표시하는 씬 1.2 Pipeline Asset Currently, Unity uses the default forward rendering pipeline. To use a custom pipeline, we have to select one in the graphics settings, which can be found via Edit / Project Settings / Graphics. 기본 파이프라인 사용 중 To setup our own pipeline, we have to assign a pipeline asset to the Scriptable Render Pipeline Settings field. Such assets have to extend RenderPipelineAsset, which is a ScriptableObject type. 우리의 커스텀 파이프라인 애셋을 위한 새 스크립트를 생성하세요. We'll simply name our pipeline My Pipeline. Its asset type will thus be MyPipelineAsset and it has to extend RenderPipelineAsset, which is defined in the UnityEngine.Experimental.Rendering namespace. using UnityEngine; using UnityEngine.Experimental.Rendering; public class MyPipelineAsset : RenderPipelineAsset {} Will it always be in the experimental namespace? It will move out of the experimental namespace at some point, either to UnityEngine.Rendering or to another namespace. When that happens, it's just a matter of updating the using statement, unless the API also gets changed. 파이프라인 애셋의 주 목적은 유니티에게 렌더링을 담당하는 파이프라인 오브젝트의 인스턴스를 유지할 방법을 제공하는 것입니다.  애셋 자체는 단지 파이프라인 설정을 저장하는 장소이자 핸들입니다. 아직 아무런 설정도 없기 때문에, 유니티에게 파이프라인 오브젝트의 인스턴스를 얻을 방법을 제공해야 합니다. This is done by overriding the InternalCreatePipeline method. But we haven't defined our pipeline object type yet, so at this point we'll just return null. The return type of InternalCreatePipeline is IRenderPipeline. The I prefix of the type name indicates that it is an interface type. public class MyPipelineAsset : RenderPipelineAsset {  protected override IRenderPipeline InternalCreatePipeline () {   return null;  } } What's an interface? 인터페이스는 클래스와 유사하지만, 구현을 제공하지 않고 기능의 계약을 정의한다는 점만 다릅니다.  프로퍼티, 이벤트, 인덱서 및 메소드 원형만 제공하며, 당연히 모두 퍼블릭이 됩니다. 인터페이스를 확장하는 모든 타입은 인터페이스가 정의한 원형들에 대한 구현을 포함해야만 합니다. The convention is to prefix interface types names with an I. Because interfaces do not contain concrete implementations, it is possible for classes and even structs to extend more than one interface. 여러 인터페이스가 같은 원형을 정의한 경우, 인터페이스들은 그 기능이 있어야 한다는 것에만 동의합니다.  클래스의 경우에는 추상 클래스라고 하더라도 이것이 불가능합니다. 구현의 충돌로 이어질 수 있기 때문입니다. 이제 이 타입의 애셋을 프로젝트에 추가해야 합니다. To make that possible, add a CreateAssetMenu attribute to MyPipelineAsset. [CreateAssetMenu] public class MyPipelineAsset : RenderPipelineAsset {} That puts an entry in the Asset / Create menu. Let's be tidy and put it in a Rendering submenu. We do this by setting the nemuName property of the attribute to Rendering/My Pipeline. 프로퍼티는 속성 타입 바로 뒤에 둥근 괄호 안에 설정할 수 있습니다. [CreateAssetMenu(menuName = "Rendering/My Pipeline")] public class MyPipelineAsset : RenderPipelineAsset {} Use the new menu item to add the asset to the project, naming it My Pipeline. 파이프라인 애셋과 스크립트 Then assign it to Scriptable Render Pipeline Settings. 사용중인 애셋 이제 기본 파이프라인을 대체했고 이로인해 몇 가지 변경이 일어납니다. 첫째, 그래픽스 설정에서 많은 옵션이 사라지며, 이는 유니티의 정보 패널에도 언급됩니다. 둘째, 유효한 대체물을 제공하지 않고 기본 파이프라인을 건너뛰었기 때문에, 더 이상 아무것도 렌더링되지 않습니다. 게임 윈도, 씬 윈도, 재질 미리보기는 더 이상 동작하지 않고, 씬 윈도만이 스카이박스를 보여줍니다. If you open the frame debugger—via Window / Analysis / Frame Debugger—and enable it, you will see that indeed nothing gets drawn in the game window. 1.3 Pipeline Instance To create a valid pipeline, we have to provide an object instance that implements IRenderPipeline and is responsible for the rendering process. So create a class for that, naming it MyPipeline. using UnityEngine; using UnityEngine.Experimental.Rendering; public class MyPipeline : IRenderPipeline {} Although we can implement IRenderPipeline ourselves, it is more convenient to extend the abstract RenderPipeline class instead. That type already provides a basic implementation of IRenderPipeline that we can build on. public class MyPipeline : RenderPipeline {} Now we can return a new instance of MyPipeline in InternalCreatePipeline. 비록 아직 아무것도 렌더링 하지 않지만 기술적으로는 우리가 유효한 파이프라인을 가지고 있다는 의미입니다.  protected override IRenderPipeline InternalCreatePipeline () {   return new MyPipeline();  } 2 Rendering The pipeline object takes care of rendering each frame. All Unity does is invoke the pipeline's Render method with a context and the cameras that are active. 이는 게임 윈도 뿐만 아니라 에디터의 씬 윈도 및 재질 미리보기에서도 수행됩니다. 적절하게 설정을 하고, 무엇을 렌더링할 파악하고, 모든 일을 올바른 순서로 수행하는 것은 우리에게 달려 있습니다. 2.1 Context RenderPipeline contains an implementation of the Render method defined in the IRenderPipeline interface. Its first argument is the render context, which is a ScriptableRenderContext struct, acting as a facade for native code. 두 번째 인수는 렌더링이 필요한 모든 카메라를 포함하는 배열입니다. RenderPipeline.Render doesn't draw anything, but checks whether the pipeline object is valid to use for rendering. 그렇지 않다면, 예외를 발생시킵니다. 우리는 이 메소드를 오버라이드 하고 이 검사를 유지하기 위해서 부모의 구현을 호출하겠습니다. public class MyPipeline : RenderPipeline {  public override void Render (   ScriptableRenderContext renderContext, Camera[] cameras  ) {   base.Render(renderContext, cameras);  } } It is through the render context that we issue commands to the Unity engine to render things and control render state. One of the simplest examples is drawing the skybox, which can be done by invoking the DrawSkyBox method.   base.Render(renderContext, cameras);   renderContext.DrawSkybox(); DrawSkybox requires a camera as a argument. We'll simply use the first element of cameras.   renderContext.DrawSkybox(cameras[0]); We still don't see the skybox appear in the game window. That's because the commands that we issue to the context are bu!ered. The actual works happens after we submit it for execution, via the Submit method.   renderContext.DrawSkybox(cameras[0]);   renderContext.Submit(); The skybox finally appears in the game window, and you can also see it appear in the frame debugger. 스카이박스가 그려지는 것을 보여주는 프레임 디버거 2.2 Cameras We are supplied with an array of cameras, because there can exist multiple in the scene that all have to be rendered. 다중 카메라 설정의 예에는 분할 화면 멀티 플레이어, 미니 맵 및 백미러가 있습니다. 각 카메라는 별도로 처리해야 합니다. 이 시점에서는 우리의 파이프라인에서 여러 카메라를 지원하는 것은 신경 쓰지 않겠습니다. We'll simply create an alternative Render method that acts on a single camera. 스카이박스를 그리고 서브밋(submit) 하세요. 그래서 우리는 카메라당 한 번씩 서브밋 합니다.  void Render (ScriptableRenderContext context, Camera camera) {   context.DrawSkybox(camera);   context.Submit();  } Invoke the new method for each element of the cameras array. I use a foreach loop in this case, as Unity's pipelines also use this approach to loop through the cameras.  public override void Render (   ScriptableRenderContext renderContext, Camera[] cameras  ) {   base.Render(renderContext, cameras);   //renderContext.DrawSkybox(cameras[0]);   //renderContext.Submit();   foreach (var camera in cameras) {    Render(renderContext, camera);   }  } How does foreach work? foreach (var e in a) { … } works like for (int i = 0; i < a.Length; a++) { var e = a[i]; … } assuming that a is an array. The only functional di!erence is that we do not have access to the iterator variable i. When a isn't an array but something else that is enumerable, then iterators come into play and you might end up with temporary object creation, which is best avoided. But using foreach with arrays is safe. The use of var to define the element variable is common, so I use it as well. Its type is the element type of a. Note that the orientation of the camera currently doesn't a!ect how the skybox gets rendered. We pass the camera to DrawSkybox, but that's only used to determine whether the skybox should be drawn at all, which is controlled via the camera clear flags. To correctly render the skybox—and the entire scene—we have to setup the view- projection matrix. 변환 행렬은 카메라의 위치와 방향 (뷰 행렬)을 카메라의 원근 혹은 직교투영 (투영행렬)과 결합합니다. 이 행렬은 프레임 디버거에서 볼 수 있습니다. It is unity_MatrixVP, one of the shader properties used when something is drawn. At the moment, the unity_MatrixVP matrix is always the same. We have to apply the camera's properties to the context, via the SetupCameraProperties method. 이 메소드는 행렬뿐 아니라 다른 프로퍼티들도 설정합니다.  void Render (ScriptableRenderContext context, Camera camera) {   context.SetupCameraProperties(camera);   context.DrawSkybox(camera);   context.Submit();  } Now the skybox gets rendered correctly, taking the camera properties into account, both in the game window and in the scene window. 2.3 Command Bu!ers The context delays the actual rendering until we submit it. 그 전에, 나중의 실행을 위해서 설정을 하고 명령들을 추가합니다. Some tasks—like drawing the skybox —can be issued via a dedicated method, but other commands have to be issued indirectly, via a separate command bu!er. A command bu!er can be created by instantiating a new CommandBuffer object, which is defined in the UnityEngine.Rendering namespace. Command bu!ers already existed before the scriptable rendering pipeline was added, so they aren't experimental. Create such a bu!er before we draw the skybox. using UnityEngine; using UnityEngine.Rendering; using UnityEngine.Experimental.Rendering; public class MyPipeline : RenderPipeline {  …  void Render (ScriptableRenderContext context, Camera camera) {   context.SetupCameraProperties(camera);   var buffer = new CommandBuffer();   context.DrawSkybox(camera);   context.Submit();  } } We can instruct the context to execute the bu!er via its ExecuteCommandBuffer method. Once again, this doesn't immediately execute the commands, but copies them to the internal bu!er of the context.   var buffer = new CommandBuffer();   context.ExecuteCommandBuffer(buffer); Command bu!ers claim resources to store their commands at the native level of the Unity engine. 이런 리소스가 더 이상 필요하지 않으면 즉시 리소스를 해제하는 것이 가장 좋습니다. This can be done by invoking the bu!er's Release method, directly after invoking ExecuteCommandBuffer.   var buffer = new CommandBuffer();   context.ExecuteCommandBuffer(buffer);   buffer.Release(); Executing an empty command bu!er does nothing. 렌더 타깃을 지울 수 있도록 그것을 추가하여, 렌더링이 이전에 그려진 것에 영향을 받지 않도록 합니다. This is possible via a command bu!er, but not directly via the context. A clear command can be added to the bu!er by invoking ClearRenderTarget. 이는 3개의 인수가 필요합니다. 2개의 부울(boolean)과 하나의 색상입니다. 첫 번째 인수는 깊이 정보를 지울지 여부를 제어하고, 두 번째는 색상 정보를 지울지 여부, 그리고 세 번째는 클리어 색상입니다.  For example, let's clear the depth data, ignore color data, and use Color.clear as the clear color.   var buffer = new CommandBuffer();   buffer.ClearRenderTarget(true, false, Color.clear);   context.ExecuteCommandBuffer(buffer);   buffer.Release(); The frame debugger will now show us that a command bu!er get executed, which clears the render target. 이 경우, Z와 스텐실이 지워지는 것으로 나타났습니다. Z refers to the depth bu!er, and the stencil bu!er always gets cleared. Clearing the depth and stencil bu!ers. 무엇을 지울지는 클리어 플래그와 배경색을 통해서 카메라별로 설정합니다. 렌더 타깃을 어떻게 지울지 하드코딩 하는 대신에 그 정보를 사용할 수 있습니다.   CameraClearFlags clearFlags = camera.clearFlags;   buffer.ClearRenderTarget(    (clearFlags & CameraClearFlags.Depth) != 0,    (clearFlags & CameraClearFlags.Color) != 0,    camera.backgroundColor   ); How do the clear flags work? CameraClearFlags is an enumeration that can be used as a set of bit flags. 값의 각 비트는 특정 기능을 사용할지 말지를 나타내는 데 사용됩니다. To extract a bit flag from the entire value, combine the value with the desired flag using the bitwise AND operator &. 결과가 0이 아니라면, 플래그는 설정된 것입니다. Because we haven't given the command bu!er a name, the debugger displays the default name, which is Unnamed command bu!er. Let's use the camera's name instead, by assigning it to the bu!er's name property. 이를 위해서 오브젝트 이니셜라이저 문법을 사용하겠습니다.    var buffer = new CommandBuffer {    name = camera.name   }; Using camera name for the command bu!er. 오브젝트 이니셜라이저 문법은 어떻게 동작하나요? We could've also written buffer.name = camera.name; as a separate statement after invoking the constructor. 그러나 새 오브젝트를 만들때 생성자의 호출에 코드 블록을 덧붙일 수 있습니다. 그 다음 오브젝트의 인스턴스를 명시적으로 참조할 필요 없이 블록에서 오브젝트의 필드와 프로퍼티를 설정할 수 있습니다. 또한, 이는 인스턴스를 그런 필드와 프로퍼티가 설정된 후에만 사용해야 한다고 명시합니다. 그 외에도, 하나의 명령문만 허용되는 상황에서 다양한 매겨변수를 갖는 생성자들이 없어도 초기화가 가능해집니다. 생성자 호출시 빈 파라미터 리스트를 생략했는데, 이는 오브젝트 이니셜라이저 문법을 사용할 때 허용됩니다. 2.4 Culling We're able to render the skybox, but not yet any of the objects that we put in the scene. 모든 오브젝트를 렌더링 하는 대신에 카메라가 볼 수 있는 것들만 렌더링하겠습니다. 이는 씬의 모든 렌더러로 시작해서 카메라의 뷰 프러스텀(절두체) 바깥에 있는 객체들을 컬링하는 식으로 수행합니다. 렌더러란 무엇인가요? 게임 오브젝트에 추가되는 컴포넌트로 게임오브젝트를 렌더링할 수 있는 어떤 것으로 바꿉니다. Typically, a MeshRenderer component. Figuring out what can be culled requires us to keep track of multiple camera settings and matrices, for which we can use the ScriptableCullingParameters struct. Instead of filling it ourselves, we can delegate that work to the static CullResults.GetCullingParameters method. 입력으로 카메라를 받고 출력으로 컬링 파라미터를 생성합니다. 그러나 파라미터 구조체를 반환하지는 않습니다. Instead, we have to supply it as a second output parameter, writing out in front of it.  void Render (ScriptableRenderContext context, Camera camera) {   ScriptableCullingParameters cullingParameters;   CullResults.GetCullingParameters(camera, out cullingParameters);   …  } Why do we have to write out? 구조체는 값 타입이므로 단순한 값처럼 취급됩니다. 독자적인 오브젝트가 아니며 변수나 필드로 메모리상의 위치에 대한 참조만 가지고 있습니다. 따라서 구조체를 인수로 넘기면 메소드에는 복사본이 전달됩니다. The method can change the copy, but that has no e!ect on the value that was copied. 구조체 파라미터가 출력 파라미터로 정의되면 오브젝트 참조처럼 동작하지만 인수가 존재하는 메모리 스택상의 위치를 가리킵니다. When the method changes that argument, it a!ects that value, not a copy. The out keyword tells us that the method is responsible for correctly setting the parameter, replacing the previous value. Besides the output parameter, GetCullingParameters also returns whether it was able to create valid parameters. 모든 카메라의 설정이 유효하지는 않으므로 컬링에 사용할 수 없는 잘못된 결과가 나올 수 있습니다. So if it fails, we have nothing to render and can exit from Render.   if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {    return;   } Once we have the culling parameters, we can use them to cull. This is done by invoking the static CullResults.Cull method with both the culling parameters and the context as arguments. The result is a CullResults struct, which contains information about what is visible. In this case, we have to supply the culling parameters as a reference parameter, by writing ref in front of it.   if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {    return;   }   CullResults cull = CullResults.Cull(ref cullingParameters, context); Why do we have to write ref? It works just like out, except in this case the method is not required to assign something to the value. 메소드를 호출하는 쪽에서 먼저 값을 올바르게 초기화 할 책임을 갖습니다. 따라서 입력을 위해 사용될 수도 있고 선택적으로 출력을 위해서 사용될 수 있습니다. Why is ScriptableCullingParameters a struct? 아마도 최적화를 위한 것으로 메모리 할당에 대해서 걱정할 필요 없이 여러 파라미터 구조체를 만들 수 있게 하려는 생각이었을 겁니다. However, ScriptableCullingParameters is very large for a struct, which is why a reference parameter is used here, again for performance reasons. 어쩌면 처음에는 작았는데 점점 더 커다란 구조체가 되었을지도 모릅니다. 재사용 가능한 오브젝트 인스턴스가 더 나은 접근방식일 수도 있지만 우리는 유니티가 결정한 방식으로 작업을 할 수 밖에 없습니다. 2.5 Drawing Once we know what is visible, we can move on to rendering those shapes. This is done by invoking DrawRenderers on the context, with cull.visibleRenderers as an argument, telling it which renderers to use. 그 외에도, 드로잉 설정과 필터 설정을 제공해야합니다. Both are structs—DrawRendererSettings and FilterRenderersSettings—for which we'll initially use their default values. 드로잉 설정은 참조로 전달해야 합니다.   buffer.Release();   var drawSettings = new DrawRendererSettings();   var filterSettings = new FilterRenderersSettings();   context.DrawRenderers(    cull.visibleRenderers, ref drawSettings, filterSettings   );   context.DrawSkybox(camera); Why FilterRenderersSettings and not FilterRendererSettings? 모르겠습니다. 어쩌면 오타일 수도 있습니다.  기본 필터 설정에는 아무것도 포함되어 있지 않으므로 아직은 아무런 오브젝트도 볼 수 없습니다. We can instead include everything by providing true as an argument for the FilterRenderersSettings constructor. 이는 모든 것을 포함하도록 초기화하라고 지시합니다.   var filterSettings = new FilterRenderersSettings(true); Also, we have to configure the draw settings by providing its constructor with the camera and a shader pass as arguments. 카메라는 정렬 및 컬링 레이어 설정에 사용되는 반면, 패스는 렌더링에 어떤 셰이더 패스를 사용할지 제어합니다. The shader pass is identified via a string, which has to be wrapped in a ShaderPassName struct. As we're only supporting unlit materials in our pipeline, we'll use Unity's default unlit pass, identified with SRPDefaultUnlit.   var drawSettings = new DrawRendererSettings(    camera, new ShaderPassName("SRPDefaultUnlit")   ); Opaque spheres are visible. 불투명한 언릿 형체들은 보이기 시작하지만 투명한 것들은 보이지 않습니다. 그러나, 프레임 디버거는 그 언릿 형체들도 그려지고 있다고 표시합니다. 모든 언릿 렌더러가 그려짐 They do get drawn, but because the transparent shader pass does not write to the depth bu!er they end up getting drawn over by the skybox. 해결 방법은 스카이박스가 그려질 때까지 투명한 렌더러의 드로잉을 지연시키는 것입니다. 우선, 스카이박스 앞쪽의 드로잉을 불투명한 렌더러로 제한하세요. This is done by setting the renderQueueRange of the filter settings to RenderQueueRange.opaque, which covers the render queues from 0 up to and including 2500.   var filterSettings = new FilterRenderersSettings(true) {    renderQueueRange = RenderQueueRange.opaque   }; Only opaque renderers are drawn. Next, change the queue range to RenderQueueRange.transparent—from 2501 up to and including 5000—after rendering the skybox, and render again.   var filterSettings = new FilterRenderersSettings(true) {    renderQueueRange = RenderQueueRange.opaque   };   context.DrawRenderers(    cull.visibleRenderers, ref drawSettings, filterSettings   );   context.DrawSkybox(camera);   filterSettings.renderQueueRange = RenderQueueRange.transparent;   context.DrawRenderers(    cull.visibleRenderers, ref drawSettings, filterSettings   ); Opaque, skybox, then transparent. 오버드로우를 방지하기 위해서 스카이박스 앞에 불투명한 렌더러들을 그립니다. 형체들이 항상 스카이박스 앞에 있기 때문에 형체들을 먼저 그림으로써 오버드로우를 피합니다.  That's because the opaque shader pass writes to the depth bu!er, which is used to skip anything that's drawn later that ends up further away. 하늘 일부를 가리는 것 외에도 불투명한 렌더러들은 서로를 가리게 될 수도 있습니다. Ideally, only the one closest to the camera is drawn for each fragment of the frame bu!er. 오버드로우를 최대한 줄이려면 가장 가까운 형체를 먼저 그려야 합니다. 드로잉 전에 렌더러들을 정렬하는 방법으로 가능하고, 이는 정렬 플래그를 통해 제어됩니다. The draw settings contain a sorting struct of type DrawRendererSortSettings, which contains the sort flags. Set it to SortFlags.CommonOpaque before drawing the opaque shapes. 이는 유니티가 렌더러들을 거리 (앞에서 뒤로) 및 추가적인 몇 가지 기준에 의해서 정렬하도록 지시합니다.   var drawSettings = new DrawRendererSettings(    camera, new ShaderPassName("SRPDefaultUnlit")   );   drawSettings.sorting.flags = SortFlags.CommonOpaque; However, transparent rendering works di!erently. 이전에 그려진 색과 지금 그려지는 색을 결합해서 결과가 투명하게 나타납니다. 이는 뒤에서 앞으로 반대의 순서로 그리는 것을 필요로 합니다. We can use SortFlags.CommonTransparent for that.   context.DrawSkybox(camera);   drawSettings.sorting.flags = SortFlags.CommonTransparent;   filterSettings.renderQueueRange = RenderQueueRange.transparent;   context.DrawRenderers(    cull.visibleRenderers, ref drawSettings, filterSettings   ); Our pipeline is now able to render both opaque and transparent unlit objects correctly. 3 Polishing Being able to render correctly is only part of having a functional pipeline. 충분히 빠른지, 불필요한 임시 오브젝트를 할당하지 않는지, 유니티 에디터와 잘 통합돠는지 등 고려해야 할 것이 더 있습니다.  3.1 Memory Allocations Let's check whether our pipeline behaves well in terms of memory management, or if it allocates memory every frame, which will trigger frequent memory garbage collection runs. This is done by opening the profiler via Window / Analysis / Profiler and inspecting the CPU Usage data in Hierarchy mode. 에디터에서 플레이 모드로 할 수도 있지만, 개발 빌드를 만들고 프로파일러에 자동으로 연결하게 해서, 빌드를 프로파일 하는 것도 좋은 생각입니다. 다만 이 경우 딥 프로파일링은 불가능합니다. (역자 주: 2017.3부터는 안드로이드에서 딥 프로파일링이 가능합니다. https://unity3d.com/learn/tutorials/topics/best-practices/unity-profiler) Sort by GC Alloc and you'll see that memory indeed gets allocated each frame. Some of it is out of our control, but quite a few bytes are allocated inside our pipeline's Render method. 컬링이 대부분의 메모리를 할당하는 것으로 밝혀졌습니다. The reason for this is that although CullResults is a struct, it contains three lists, which are objects. 매번 우리가 새로운 컬링 결과를 요구할 때마다 새 리스트들을 위해서 메모리를 할당하게 됩니다. So there isn't much benefit to CullResults being a struct. Fortunately, CullResults has an alternative Cull method that accepts a struct as a reference parameter, instead of returning a new one. 이렇게 하면 리스트들의 재사용이 가능해집니다. All we have to do is turn cull into a field and provide it as an additional argument to CullResults.Cull, instead of assigning to it.  CullResults cull;  …  void Render (ScriptableRenderContext context, Camera camera) {   …   //CullResults cull = CullResults.Cull(ref cullingParameters, context);   CullResults.Cull(ref cullingParameters, context, ref cull); 

  …  } Another source of continuous memory allocation is our use of the camera's name property. 매번 그 값을 얻을 때마다 네이티브 코드에서 이름을 가져오므로 새 문자열을 생성해야 하고, 문자열은 오브젝트입니다. So let's always name our command bu!er Render Camera instead.   var buffer = new CommandBuffer() {    name = "Render Camera"   }; Using a constant bu!er name. Finally, the command bu!er itself is an object too. Fortunately, we can create a command bu!er once and reuse it. Replace the local variable with a cameraBuffer field. Thanks to the object initialization syntax, we can create a named command bu!er as its default value. The only other change is that we have to clear the command bu!er instead of releasing it, for which we can use its Clear method.  CommandBuffer cameraBuffer = new CommandBuffer {   name = "Render Camera"  };  …  void Render (ScriptableRenderContext context, Camera camera) {   …   //var buffer = new CommandBuffer() {   // name = "Render Camera"   //};   cameraBuffer.ClearRenderTarget(true, false, Color.clear);   context.ExecuteCommandBuffer(cameraBuffer);   //buffer.Release();   cameraBuffer.Clear();   …  } After these changes our pipeline no longer creates temporary objects every frame. 3.2 Frame Debugger Sampling Another thing that we can do is improve the data shown by the frame debugger. 유니티의 파이프라인은 이벤트의 중첩된 계층 구조를 보여주지만, 우리의 파이프라인은 모두 최상위 단계에 있습니다.   We can build a hierarchy by using our command bu!er to begin and end profiler samples. Let's start by invoking BeginSample right before ClearRenderTarget, immediately followed by an invocation of EndSample. 모든 샘플은 시작과 끝을 가져야 하며 둘 다 정확히 같은 이름으로 제공되어야 합니다.  Besides that, I have found that it is best to use the same name as the command bu!er that defines the sampling. The command bu!er's name often gets used anyway.   cameraBuffer.BeginSample("Render Camera");   cameraBuffer.ClearRenderTarget(true, false, Color.clear);   cameraBuffer.EndSample("Render Camera");   context.ExecuteCommandBuffer(cameraBuffer);   cameraBuffer.Clear(); Sampling creates a hierarchy. We now see a Render Camera level nested inside the original Render Camera of the command bu!er, which in turn contains the clear operation. 그러나 한 단계 더 나아가서 카메라와 관련된 모든 동작도 그 안에 포함할 수 있습니다. 이를 위해서는 콘텍스트를 서브밋 하기 직전까지 샘플의 종료를 지연해야 합니다. So we have to insert an additional ExecuteCommandBuffer at that point, only containing the instruction to end the sample. Use the same command bu!er for this, again clearing it after we are done.   cameraBuffer.BeginSample("Render Camera");   cameraBuffer.ClearRenderTarget(true, false, Color.clear);   //cameraBuffer.EndSample("Render Camera");   context.ExecuteCommandBuffer(cameraBuffer);   cameraBuffer.Clear();   …   cameraBuffer.EndSample("Render Camera");   context.ExecuteCommandBuffer(cameraBuffer);   cameraBuffer.Clear();   context.Submit(); Nested sampling. This looks good, except that the clear action gets nested inside a redundant Render Camera level, while all other actions are directly below the root level. 왜 이런 일이 발생하는지 확신할 수 없지만 지운 후에 샘플을 시작하는 것으로 이 문제를 피할 수 있습니다.    //cameraBuffer.BeginSample("Render Camera");   cameraBuffer.ClearRenderTarget(true, false, Color.clear);   cameraBuffer.BeginSample("Render Camera");   context.ExecuteCommandBuffer(cameraBuffer);   cameraBuffer.Clear(); No redundant nesting. 3.3 Rendering the Default Pipeline Because our pipeline only supports unlit shaders, objects that use di!erent shaders are not rendered, making them invisible. 올바른 동작이지만, 이는 일부 오브젝트가 잘못된 셰이더를 사용한다는 사실을 숨깁니다. 유니티의 에러 셰이더로 그러한 오브젝트를 시각화해서 명백히 잘못된 마젠타 형체으로 나타나게 된다면 좋을 것 같습니다. Let's add a dedicated DrawDefaultPipeline method for this, with a context and a camera parameter. 투명한 형체들을 그린 후에 마지막에 호출하겠습니다.  void Render (ScriptableRenderContext context, Camera camera) {   …   drawSettings.sorting.flags = SortFlags.CommonTransparent;   filterSettings.renderQueueRange = RenderQueueRange.transparent;   context.DrawRenderers(    cull.visibleRenderers, ref drawSettings, filterSettings   );   DrawDefaultPipeline(context, camera);   cameraBuffer.EndSample("Render Camera");   context.ExecuteCommandBuffer(cameraBuffer);   cameraBuffer.Clear();   context.Submit();  }  void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {} Unity's default surface shader has a ForwardBase pass that is used as the first forward rendering pass. 이를 활용해서 오브젝트가 기본 파이프라인과 함께 작동하는 재질을 가졌는지 식별할 수 있습니다.  새로운 드로잉 설정을 통해서 해당 패스를 선택하고 렌더링을 위해 새로운 기본 필터 설정과 함께 사용하세요. 정렬이나 투명과 불투명 렌더러를 구분하는 것은 신경쓰지 않습니다. 어쨌든 효과가 없기 때문입니다.  void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {   var drawSettings = new DrawRendererSettings(    camera, new ShaderPassName("ForwardBase")   ); 

  var filterSettings = new FilterRenderersSettings(true); 

  context.DrawRenderers(    cull.visibleRenderers, ref drawSettings, filterSettings   );  } Rendering forward base pass. 이제 기본 셰이더를 사용하는 오브젝트가 나타납니다. 프레임 디버거에서도 보입니다. 모든 것이 그려집니다. 우리의 파이프라인은 포워드 베이스 패스를 지원하지 않기 때문에 올바르게 렌더링 되지 않습니다.  필요한 데이터가 설정되지 않았으므로 라이팅에 의존하는 모든 것이 검은색이 되어 버립니다. 대신, 에러 셰이더를 사용해 렌더링 해야 합니다.  이렇게 하려면 에러 재질이 필요합니다. 그것을 위해서 필드를 추가하세요. Then, at the start of DrawDefaultPipeline, create the error material if it doesn't already exist. This is done by retrieving the Hidden/InternalErrorShader via Shader.Find, then creating a new material with that shader. Also, set the material's hide flags to HideFlags.HideAndDontSave so it doesn't show up in the project window and doesn't get saved along with all other assets.  Material errorMaterial;  …  void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {   if (errorMaterial == null) {    Shader errorShader = Shader.Find("Hidden/InternalErrorShader");    errorMaterial = new Material(errorShader) {     hideFlags = HideFlags.HideAndDontSave    };   } 

  …  } One option of the draw settings is to override the material used when rendering, by invoking SetOverrideMaterial. 첫 번째 파라미터는 사용할 재질입니다. 두 번째 파라미터는 렌더링에 사용될 재질의 셰이더 패스의 인덱스입니다. 에러 셰이더는 단일 패스만 가지므로 0을 사용하세요.   var drawSettings = new DrawRendererSettings(    camera, new ShaderPassName("ForwardBase")   );   drawSettings.SetOverrideMaterial(errorMaterial, 0); Using the error shader. 지원하지 않는 재질을 사용하는 오브젝트들은 이제 확실히 잘못된 것처럼 보입니다. But this is only true for materials of Unity's default pipeline, whose shaders have a ForwardBase pass. There are other built-in shaders that we can identify with di!erent passes, specifically PrepassBase, Always, Vertex, VertexLMRGBM, and VertexLM. Fortunately, it is possible to add multiple passes to the draw settings, by invoking SetShaderPassName. 이름은 이 메소드의 두 번째 파라미터입니다. 첫 번째 파라미터는 해당 패스가 그려지는 순서를 제어하는 인덱스입니다. 무엇이든 상관없으니 아무 순서나 넣어도 괜찮습니다. 생성자를 통해 제공된 패스는 언제나 인덱스 0을 갖습니다. 추가적인 패스를 위해 인덱스를 하나씩 증가시킵니다.   var drawSettings = new DrawRendererSettings(    camera, new ShaderPassName("ForwardBase")   );   drawSettings.SetShaderPassName(1, new ShaderPassName("PrepassBase"));   drawSettings.SetShaderPassName(2, new ShaderPassName("Always"));   drawSettings.SetShaderPassName(3, new ShaderPassName("Vertex"));   drawSettings.SetShaderPassName(4, new ShaderPassName("VertexLMRGBM"));   drawSettings.SetShaderPassName(5, new ShaderPassName("VertexLM"));   drawSettings.SetOverrideMaterial(errorMaterial, 0); That covers all shaders provided by Unity up to this point, which should be su"cient to help point out the use of incorrect materials when creating a scene. 그러나 개발 과정에서만 이 작업이 필요한 것이지 빌드에서는 필요하지 않습니다. So let's only invoke DrawDefaultPipeline in the editor. One way to do this is by adding a Conditional attribute to the method. 3.4 Conditional Code Execution The Conditional attribute is defined in the System.Diagnostics namespace. We can use that namespace, but it unfortunately also contains a Debug type, which conflicts with UnityEngine.Debug. 우리는 해당 속성만 필요하므로 별칭을 사용해서 충돌을 피할 수 있습니다. 전체 네임스페이스를 사용하는 대신 특정 타입을 사용하고 그 타입에 유효한 이름을 할당합니다. In this case, we'll define Conditional as an alias for System.Diagnostics.ConditionalAttribute. using UnityEngine; using UnityEngine.Rendering; using UnityEngine.Experimental.Rendering; using Conditional = System.Diagnostics.ConditionalAttribute; Add the attribute to our method. 심볼을 지정하는 문자열 인수가 필요합니다. 컴파일 중에 해당 심볼이 정의되어 있으면 메소드 호출은 정상적으로 포함이 됩니다. 그러나 만약 심볼이 정의되어 있지 않다면 모든 인자와 함께 이 메소드의 호출은 제거됩니다. It would be as if the DrawDefaultPipeline(context, camera); code didn't exist during compilation. To only include the invocation when compiling for the Unity editor, we have to rely on the UNITY_EDITOR symbol.  [Conditional("UNITY_EDITOR")]  void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {   …  } We can go a step further and also include the invocation in development builds, only excluding it from release builds. To do so, add an additional conditional with the DEVELOPMENT_BUILD symbol.  [Conditional("DEVELOPMENT_BUILD"), Conditional("UNITY_EDITOR")]  void DrawDefaultPipeline(ScriptableRenderContext context, Camera camera) {   …  } 3.5 UI in Scene Window One thing that we haven't considered up to this point is Unity's in-game UI. To test it, add a UI element to the scene, for example a single button, via GameObject / UI / Button. 버튼이 들어있는 캔버스와 이벤트 시스템이 만들어집니다. 우리가 아무것도 하지 않아도 UI가 게임 윈도안에 렌더링 되는 것으로 밝혀졌습니다.  유니티가 알아서 해줍니다. 프레임 디버거는 UI가 오버레이로 별도로 렌더링되는 것을 보여줍니다.  UI가 스크린 스페이스에 그려집니다. 적어도, 캔버스가 스크린 스페이스에 렌더링되도록 설정된 경우입니다. 월드 스페이스에 렌더링하도록 설정된 경우, UI가 다른 투명한 오브젝트들과 함께 렌더링됩니다. 월드 스페이스의 UI UI가 게임 윈도에서는 동작하지만 씬 윈도에는 나타나지 않습니다. 씬 윈도에서 UI는 항상 월드 스페이스에 존재하지만 수동으로 씬에 삽입해야 합니다. Adding the UI is done by invoking the static ScriptableRenderContext.EmitWorldGeometryForSceneView method, with the current camera as an argument. 컬링 전에 수행되어야 합니다.   if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {    return;   }   ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);   CullResults.Cull(ref cullingParameters, context, ref cull); But this also adds the UI a second time in the game window. 이를 방지하려면, 씬 윈도를 렌더링할 때만 UI 지오메트리를 내보내야 합니다.  This is the case when the cameraType of the camera is equal to CameraType.SceneView.   if (camera.cameraType == CameraType.SceneView) {    ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);   } This works, but only in the editor. Conditional compilation makes sure that the EmitWorldGeometryForSceneView doesn't exist when compiling for a build, which means that we now get a compiler error when trying to build. To make it work again, we have to make the code that invokes EmitWorldGeometryForSceneView conditional as well. That is done by putting the code in between #if and #endif statements. The #if statement requires a symbol, just like the Conditional attribute. By using UNITY_EDITOR, the code to only get included when compiling for the editor.  void Render (ScriptableRenderContext context, Camera camera) {   ScriptableCullingParameters cullingParameters;   if (!CullResults.GetCullingParameters(camera, out cullingParameters)) {    return;   } #if UNITY_EDITOR   if (camera.cameraType == CameraType.SceneView) {    ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);   } #endif   CullResults.Cull(ref cullingParameters, context, ref cull);   …  } The next tutorial is Custom Shaders. repository Enjoying the tutorials? 도움이 되나요? 더 보고 싶으세요? Patreon에서 저를 지원해주세요! Or make a direct donation! made by Jasper Flick 
